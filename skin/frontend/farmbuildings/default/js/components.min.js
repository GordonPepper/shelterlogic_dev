!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory(jQuery);
}(function($) {
    function args(elem) {
        var newAttrs = {}, rinlinejQuery = /^jQuery\d+$/;
        return $.each(elem.attributes, function(i, attr) {
            attr.specified && !rinlinejQuery.test(attr.name) && (newAttrs[attr.name] = attr.value);
        }), newAttrs;
    }
    function clearPlaceholder(event, value) {
        var input = this, $input = $(input);
        if (input.value == $input.attr("placeholder") && $input.hasClass("placeholder")) if ($input.data("placeholder-password")) {
            if ($input = $input.hide().nextAll('input[type="password"]:first').show().attr("id", $input.removeAttr("id").data("placeholder-id")), 
            event === !0) return $input[0].value = value;
            $input.focus();
        } else input.value = "", $input.removeClass("placeholder"), input == safeActiveElement() && input.select();
    }
    function setPlaceholder() {
        var $replacement, input = this, $input = $(input), id = this.id;
        if ("" === input.value) {
            if ("password" === input.type) {
                if (!$input.data("placeholder-textinput")) {
                    try {
                        $replacement = $input.clone().attr({
                            type: "text"
                        });
                    } catch (e) {
                        $replacement = $("<input>").attr($.extend(args(this), {
                            type: "text"
                        }));
                    }
                    $replacement.removeAttr("name").data({
                        "placeholder-password": $input,
                        "placeholder-id": id
                    }).bind("focus.placeholder", clearPlaceholder), $input.data({
                        "placeholder-textinput": $replacement,
                        "placeholder-id": id
                    }).before($replacement);
                }
                $input = $input.removeAttr("id").hide().prevAll('input[type="text"]:first').attr("id", id).show();
            }
            $input.addClass("placeholder"), $input[0].value = $input.attr("placeholder");
        } else $input.removeClass("placeholder");
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (exception) {}
    }
    var hooks, placeholder, isOperaMini = "[object OperaMini]" == Object.prototype.toString.call(window.operamini), isInputSupported = "placeholder" in document.createElement("input") && !isOperaMini, isTextareaSupported = "placeholder" in document.createElement("textarea") && !isOperaMini, valHooks = $.valHooks, propHooks = $.propHooks;
    isInputSupported && isTextareaSupported ? (placeholder = $.fn.placeholder = function() {
        return this;
    }, placeholder.input = placeholder.textarea = !0) : (placeholder = $.fn.placeholder = function() {
        var $this = this;
        return $this.filter((isInputSupported ? "textarea" : ":input") + "[placeholder]").not(".placeholder").bind({
            "focus.placeholder": clearPlaceholder,
            "blur.placeholder": setPlaceholder
        }).data("placeholder-enabled", !0).trigger("blur.placeholder"), $this;
    }, placeholder.input = isInputSupported, placeholder.textarea = isTextareaSupported, 
    hooks = {
        get: function(element) {
            var $element = $(element), $passwordInput = $element.data("placeholder-password");
            return $passwordInput ? $passwordInput[0].value : $element.data("placeholder-enabled") && $element.hasClass("placeholder") ? "" : element.value;
        },
        set: function(element, value) {
            var $element = $(element), $passwordInput = $element.data("placeholder-password");
            return $passwordInput ? $passwordInput[0].value = value : $element.data("placeholder-enabled") ? ("" === value ? (element.value = value, 
            element != safeActiveElement() && setPlaceholder.call(element)) : $element.hasClass("placeholder") ? clearPlaceholder.call(element, !0, value) || (element.value = value) : element.value = value, 
            $element) : element.value = value;
        }
    }, isInputSupported || (valHooks.input = hooks, propHooks.value = hooks), isTextareaSupported || (valHooks.textarea = hooks, 
    propHooks.value = hooks), $(function() {
        $(document).delegate("form", "submit.placeholder", function() {
            var $inputs = $(".placeholder", this).each(clearPlaceholder);
            setTimeout(function() {
                $inputs.each(setPlaceholder);
            }, 10);
        });
    }), $(window).bind("beforeunload.placeholder", function() {
        $(".placeholder").each(function() {
            this.value = "";
        });
    }));
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory("object" == typeof exports ? require("jquery") : jQuery);
}(function($) {
    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }
    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }
    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }
    function parseCookieValue(s) {
        0 === s.indexOf('"') && (s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\"));
        try {
            return s = decodeURIComponent(s.replace(pluses, " ")), config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }
    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }
    var pluses = /\+/g, config = $.cookie = function(key, value, options) {
        if (void 0 !== value && !$.isFunction(value)) {
            if (options = $.extend({}, config.defaults, options), "number" == typeof options.expires) {
                var days = options.expires, t = options.expires = new Date();
                t.setTime(+t + 864e5 * days);
            }
            return document.cookie = [ encode(key), "=", stringifyCookieValue(value), options.expires ? "; expires=" + options.expires.toUTCString() : "", options.path ? "; path=" + options.path : "", options.domain ? "; domain=" + options.domain : "", options.secure ? "; secure" : "" ].join("");
        }
        for (var result = key ? void 0 : {}, cookies = document.cookie ? document.cookie.split("; ") : [], i = 0, l = cookies.length; l > i; i++) {
            var parts = cookies[i].split("="), name = decode(parts.shift()), cookie = parts.join("=");
            if (key && key === name) {
                result = read(cookie, value);
                break;
            }
            key || void 0 === (cookie = read(cookie)) || (result[name] = cookie);
        }
        return result;
    };
    config.defaults = {}, $.removeCookie = function(key, options) {
        return void 0 === $.cookie(key) ? !1 : ($.cookie(key, "", $.extend({}, options, {
            expires: -1
        })), !$.cookie(key));
    };
}), function(w) {
    "use strict";
    function callMedia() {
        applyMedia(!0);
    }
    var respond = {};
    w.respond = respond, respond.update = function() {};
    var requestQueue = [], xmlHttp = function() {
        var xmlhttpmethod = !1;
        try {
            xmlhttpmethod = new w.XMLHttpRequest();
        } catch (e) {
            xmlhttpmethod = new w.ActiveXObject("Microsoft.XMLHTTP");
        }
        return function() {
            return xmlhttpmethod;
        };
    }(), ajax = function(url, callback) {
        var req = xmlHttp();
        req && (req.open("GET", url, !0), req.onreadystatechange = function() {
            4 !== req.readyState || 200 !== req.status && 304 !== req.status || callback(req.responseText);
        }, 4 !== req.readyState && req.send(null));
    };
    if (respond.ajax = ajax, respond.queue = requestQueue, respond.regex = {
        media: /@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,
        keyframes: /@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,
        urls: /(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,
        findStyles: /@media *([^\{]+)\{([\S\s]+?)$/,
        only: /(only\s+)?([a-zA-Z]+)\s?/,
        minw: /\([\s]*min\-width\s*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/,
        maxw: /\([\s]*max\-width\s*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/
    }, respond.mediaQueriesSupported = w.matchMedia && null !== w.matchMedia("only all") && w.matchMedia("only all").matches, 
    !respond.mediaQueriesSupported) {
        var lastCall, resizeDefer, eminpx, doc = w.document, docElem = doc.documentElement, mediastyles = [], rules = [], appendedEls = [], parsedSheets = {}, resizeThrottle = 30, head = doc.getElementsByTagName("head")[0] || docElem, base = doc.getElementsByTagName("base")[0], links = head.getElementsByTagName("link"), getEmValue = function() {
            var ret, div = doc.createElement("div"), body = doc.body, originalHTMLFontSize = docElem.style.fontSize, originalBodyFontSize = body && body.style.fontSize, fakeUsed = !1;
            return div.style.cssText = "position:absolute;font-size:1em;width:1em", body || (body = fakeUsed = doc.createElement("body"), 
            body.style.background = "none"), docElem.style.fontSize = "100%", body.style.fontSize = "100%", 
            body.appendChild(div), fakeUsed && docElem.insertBefore(body, docElem.firstChild), 
            ret = div.offsetWidth, fakeUsed ? docElem.removeChild(body) : body.removeChild(div), 
            docElem.style.fontSize = originalHTMLFontSize, originalBodyFontSize && (body.style.fontSize = originalBodyFontSize), 
            ret = eminpx = parseFloat(ret);
        }, applyMedia = function(fromResize) {
            var name = "clientWidth", docElemProp = docElem[name], currWidth = "CSS1Compat" === doc.compatMode && docElemProp || doc.body[name] || docElemProp, styleBlocks = {}, lastLink = links[links.length - 1], now = new Date().getTime();
            if (fromResize && lastCall && resizeThrottle > now - lastCall) return w.clearTimeout(resizeDefer), 
            void (resizeDefer = w.setTimeout(applyMedia, resizeThrottle));
            lastCall = now;
            for (var i in mediastyles) if (mediastyles.hasOwnProperty(i)) {
                var thisstyle = mediastyles[i], min = thisstyle.minw, max = thisstyle.maxw, minnull = null === min, maxnull = null === max, em = "em";
                min && (min = parseFloat(min) * (min.indexOf(em) > -1 ? eminpx || getEmValue() : 1)), 
                max && (max = parseFloat(max) * (max.indexOf(em) > -1 ? eminpx || getEmValue() : 1)), 
                thisstyle.hasquery && (minnull && maxnull || !(minnull || currWidth >= min) || !(maxnull || max >= currWidth)) || (styleBlocks[thisstyle.media] || (styleBlocks[thisstyle.media] = []), 
                styleBlocks[thisstyle.media].push(rules[thisstyle.rules]));
            }
            for (var j in appendedEls) appendedEls.hasOwnProperty(j) && appendedEls[j] && appendedEls[j].parentNode === head && head.removeChild(appendedEls[j]);
            appendedEls.length = 0;
            for (var k in styleBlocks) if (styleBlocks.hasOwnProperty(k)) {
                var ss = doc.createElement("style"), css = styleBlocks[k].join("\n");
                ss.type = "text/css", ss.media = k, head.insertBefore(ss, lastLink.nextSibling), 
                ss.styleSheet ? ss.styleSheet.cssText = css : ss.appendChild(doc.createTextNode(css)), 
                appendedEls.push(ss);
            }
        }, translate = function(styles, href, media) {
            var qs = styles.replace(respond.regex.keyframes, "").match(respond.regex.media), ql = qs && qs.length || 0;
            href = href.substring(0, href.lastIndexOf("/"));
            var repUrls = function(css) {
                return css.replace(respond.regex.urls, "$1" + href + "$2$3");
            }, useMedia = !ql && media;
            href.length && (href += "/"), useMedia && (ql = 1);
            for (var i = 0; ql > i; i++) {
                var fullq, thisq, eachq, eql;
                useMedia ? (fullq = media, rules.push(repUrls(styles))) : (fullq = qs[i].match(respond.regex.findStyles) && RegExp.$1, 
                rules.push(RegExp.$2 && repUrls(RegExp.$2))), eachq = fullq.split(","), eql = eachq.length;
                for (var j = 0; eql > j; j++) thisq = eachq[j], mediastyles.push({
                    media: thisq.split("(")[0].match(respond.regex.only) && RegExp.$2 || "all",
                    rules: rules.length - 1,
                    hasquery: thisq.indexOf("(") > -1,
                    minw: thisq.match(respond.regex.minw) && parseFloat(RegExp.$1) + (RegExp.$2 || ""),
                    maxw: thisq.match(respond.regex.maxw) && parseFloat(RegExp.$1) + (RegExp.$2 || "")
                });
            }
            applyMedia();
        }, makeRequests = function() {
            if (requestQueue.length) {
                var thisRequest = requestQueue.shift();
                ajax(thisRequest.href, function(styles) {
                    translate(styles, thisRequest.href, thisRequest.media), parsedSheets[thisRequest.href] = !0, 
                    w.setTimeout(function() {
                        makeRequests();
                    }, 0);
                });
            }
        }, ripCSS = function() {
            for (var i = 0; i < links.length; i++) {
                var sheet = links[i], href = sheet.href, media = sheet.media, isCSS = sheet.rel && "stylesheet" === sheet.rel.toLowerCase();
                href && isCSS && !parsedSheets[href] && (sheet.styleSheet && sheet.styleSheet.rawCssText ? (translate(sheet.styleSheet.rawCssText, href, media), 
                parsedSheets[href] = !0) : (!/^([a-zA-Z:]*\/\/)/.test(href) && !base || href.replace(RegExp.$1, "").split("/")[0] === w.location.host) && ("//" === href.substring(0, 2) && (href = w.location.protocol + href), 
                requestQueue.push({
                    href: href,
                    media: media
                })));
            }
            makeRequests();
        };
        ripCSS(), respond.update = ripCSS, respond.getEmValue = getEmValue, w.addEventListener ? w.addEventListener("resize", callMedia, !1) : w.attachEvent && w.attachEvent("onresize", callMedia);
    }
}(this), function($, window, document, undefined) {
    "use strict";
    function removeQuotes(string) {
        return ("string" == typeof string || string instanceof String) && (string = string.replace(/^['\\/"]+|(;\s?})+|['\\/"]+$/g, "")), 
        string;
    }
    var header_helpers = function(class_array) {
        for (var i = class_array.length, head = $("head"); i--; ) 0 === head.has("." + class_array[i]).length && head.append('<meta class="' + class_array[i] + '" />');
    };
    header_helpers([ "foundation-mq-small", "foundation-mq-medium", "foundation-mq-large", "foundation-mq-xlarge", "foundation-mq-xxlarge", "foundation-data-attribute-namespace" ]), 
    $(function() {
        "undefined" != typeof FastClick && "undefined" != typeof document.body && FastClick.attach(document.body);
    });
    var S = function(selector, context) {
        if ("string" == typeof selector) {
            if (context) {
                var cont;
                if (context.jquery) {
                    if (cont = context[0], !cont) return context;
                } else cont = context;
                return $(cont.querySelectorAll(selector));
            }
            return $(document.querySelectorAll(selector));
        }
        return $(selector, context);
    }, attr_name = function(init) {
        var arr = [];
        return init || arr.push("data"), this.namespace.length > 0 && arr.push(this.namespace), 
        arr.push(this.name), arr.join("-");
    }, add_namespace = function(str) {
        for (var parts = str.split("-"), i = parts.length, arr = []; i--; ) 0 !== i ? arr.push(parts[i]) : this.namespace.length > 0 ? arr.push(this.namespace, parts[i]) : arr.push(parts[i]);
        return arr.reverse().join("-");
    }, bindings = function(method, options) {
        var self = this, should_bind_events = !S(this).data(this.attr_name(!0));
        return S(this.scope).is("[" + this.attr_name() + "]") ? (S(this.scope).data(this.attr_name(!0) + "-init", $.extend({}, this.settings, options || method, this.data_options(S(this.scope)))), 
        should_bind_events && this.events(this.scope)) : S("[" + this.attr_name() + "]", this.scope).each(function() {
            var should_bind_events = !S(this).data(self.attr_name(!0) + "-init");
            S(this).data(self.attr_name(!0) + "-init", $.extend({}, self.settings, options || method, self.data_options(S(this)))), 
            should_bind_events && self.events(this);
        }), "string" == typeof method ? this[method].call(this, options) : void 0;
    }, single_image_loaded = function(image, callback) {
        function loaded() {
            callback(image[0]);
        }
        function bindLoad() {
            if (this.one("load", loaded), /MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
                var src = this.attr("src"), param = src.match(/\?/) ? "&" : "?";
                param += "random=" + new Date().getTime(), this.attr("src", src + param);
            }
        }
        return image.attr("src") ? void (image[0].complete || 4 === image[0].readyState ? loaded() : bindLoad.call(image)) : void loaded();
    };
    window.matchMedia = window.matchMedia || function(doc) {
        var bool, docElem = doc.documentElement, refNode = docElem.firstElementChild || docElem.firstChild, fakeBody = doc.createElement("body"), div = doc.createElement("div");
        return div.id = "mq-test-1", div.style.cssText = "position:absolute;top:-100em", 
        fakeBody.style.background = "none", fakeBody.appendChild(div), function(q) {
            return div.innerHTML = '&shy;<style media="' + q + '"> #mq-test-1 { width: 42px; }</style>', 
            docElem.insertBefore(fakeBody, refNode), bool = 42 === div.offsetWidth, docElem.removeChild(fakeBody), 
            {
                matches: bool,
                media: q
            };
        };
    }(document), function() {
        function raf() {
            animating && (requestAnimationFrame(raf), jqueryFxAvailable && jQuery.fx.tick());
        }
        for (var animating, lastTime = 0, vendors = [ "webkit", "moz" ], requestAnimationFrame = window.requestAnimationFrame, cancelAnimationFrame = window.cancelAnimationFrame, jqueryFxAvailable = "undefined" != typeof jQuery.fx; lastTime < vendors.length && !requestAnimationFrame; lastTime++) requestAnimationFrame = window[vendors[lastTime] + "RequestAnimationFrame"], 
        cancelAnimationFrame = cancelAnimationFrame || window[vendors[lastTime] + "CancelAnimationFrame"] || window[vendors[lastTime] + "CancelRequestAnimationFrame"];
        requestAnimationFrame ? (window.requestAnimationFrame = requestAnimationFrame, window.cancelAnimationFrame = cancelAnimationFrame, 
        jqueryFxAvailable && (jQuery.fx.timer = function(timer) {
            timer() && jQuery.timers.push(timer) && !animating && (animating = !0, raf());
        }, jQuery.fx.stop = function() {
            animating = !1;
        })) : (window.requestAnimationFrame = function(callback) {
            var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            return lastTime = currTime + timeToCall, id;
        }, window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        });
    }(jQuery), window.Foundation = {
        name: "Foundation",
        version: "5.4.7",
        media_queries: {
            small: S(".foundation-mq-small").css("font-family").replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ""),
            medium: S(".foundation-mq-medium").css("font-family").replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ""),
            large: S(".foundation-mq-large").css("font-family").replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ""),
            xlarge: S(".foundation-mq-xlarge").css("font-family").replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ""),
            xxlarge: S(".foundation-mq-xxlarge").css("font-family").replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, "")
        },
        stylesheet: $("<style></style>").appendTo("head")[0].sheet,
        global: {
            namespace: undefined
        },
        init: function(scope, libraries, method, options, response) {
            var args = [ scope, method, options, response ], responses = [];
            if (this.rtl = /rtl/i.test(S("html").attr("dir")), this.scope = scope || this.scope, 
            this.set_namespace(), libraries && "string" == typeof libraries && !/reflow/i.test(libraries)) this.libs.hasOwnProperty(libraries) && responses.push(this.init_lib(libraries, args)); else for (var lib in this.libs) responses.push(this.init_lib(lib, libraries));
            return S(window).load(function() {
                S(window).trigger("resize.fndtn.clearing").trigger("resize.fndtn.dropdown").trigger("resize.fndtn.equalizer").trigger("resize.fndtn.interchange").trigger("resize.fndtn.joyride").trigger("resize.fndtn.magellan").trigger("resize.fndtn.topbar").trigger("resize.fndtn.slider");
            }), scope;
        },
        init_lib: function(lib, args) {
            return this.libs.hasOwnProperty(lib) ? (this.patch(this.libs[lib]), args && args.hasOwnProperty(lib) ? ("undefined" != typeof this.libs[lib].settings ? $.extend(!0, this.libs[lib].settings, args[lib]) : "undefined" != typeof this.libs[lib].defaults && $.extend(!0, this.libs[lib].defaults, args[lib]), 
            this.libs[lib].init.apply(this.libs[lib], [ this.scope, args[lib] ])) : (args = args instanceof Array ? args : new Array(args), 
            this.libs[lib].init.apply(this.libs[lib], args))) : function() {};
        },
        patch: function(lib) {
            lib.scope = this.scope, lib.namespace = this.global.namespace, lib.rtl = this.rtl, 
            lib.data_options = this.utils.data_options, lib.attr_name = attr_name, lib.add_namespace = add_namespace, 
            lib.bindings = bindings, lib.S = this.utils.S;
        },
        inherit: function(scope, methods) {
            for (var methods_arr = methods.split(" "), i = methods_arr.length; i--; ) this.utils.hasOwnProperty(methods_arr[i]) && (scope[methods_arr[i]] = this.utils[methods_arr[i]]);
        },
        set_namespace: function() {
            var namespace = this.global.namespace === undefined ? $(".foundation-data-attribute-namespace").css("font-family") : this.global.namespace;
            this.global.namespace = namespace === undefined || /false/i.test(namespace) ? "" : namespace;
        },
        libs: {},
        utils: {
            S: S,
            throttle: function(func, delay) {
                var timer = null;
                return function() {
                    var context = this, args = arguments;
                    null == timer && (timer = setTimeout(function() {
                        func.apply(context, args), timer = null;
                    }, delay));
                };
            },
            debounce: function(func, delay, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later = function() {
                        timeout = null, immediate || (result = func.apply(context, args));
                    }, callNow = immediate && !timeout;
                    return clearTimeout(timeout), timeout = setTimeout(later, delay), callNow && (result = func.apply(context, args)), 
                    result;
                };
            },
            data_options: function(el, data_attr_name) {
                function isNumber(o) {
                    return !isNaN(o - 0) && null !== o && "" !== o && o !== !1 && o !== !0;
                }
                function trim(str) {
                    return "string" == typeof str ? $.trim(str) : str;
                }
                data_attr_name = data_attr_name || "options";
                var ii, p, opts_arr, opts = {}, data_options = function(el) {
                    var namespace = Foundation.global.namespace;
                    return el.data(namespace.length > 0 ? namespace + "-" + data_attr_name : data_attr_name);
                }, cached_options = data_options(el);
                if ("object" == typeof cached_options) return cached_options;
                for (opts_arr = (cached_options || ":").split(";"), ii = opts_arr.length; ii--; ) p = opts_arr[ii].split(":"), 
                p = [ p[0], p.slice(1).join(":") ], /true/i.test(p[1]) && (p[1] = !0), /false/i.test(p[1]) && (p[1] = !1), 
                isNumber(p[1]) && (p[1] = -1 === p[1].indexOf(".") ? parseInt(p[1], 10) : parseFloat(p[1])), 
                2 === p.length && p[0].length > 0 && (opts[trim(p[0])] = trim(p[1]));
                return opts;
            },
            register_media: function(media, media_class) {
                Foundation.media_queries[media] === undefined && ($("head").append('<meta class="' + media_class + '"/>'), 
                Foundation.media_queries[media] = removeQuotes($("." + media_class).css("font-family")));
            },
            add_custom_rule: function(rule, media) {
                if (media === undefined && Foundation.stylesheet) Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length); else {
                    var query = Foundation.media_queries[media];
                    query !== undefined && Foundation.stylesheet.insertRule("@media " + Foundation.media_queries[media] + "{ " + rule + " }");
                }
            },
            image_loaded: function(images, callback) {
                var self = this, unloaded = images.length;
                0 === unloaded && callback(images), images.each(function() {
                    single_image_loaded(self.S(this), function() {
                        unloaded -= 1, 0 === unloaded && callback(images);
                    });
                });
            },
            random_str: function() {
                return this.fidx || (this.fidx = 0), this.prefix = this.prefix || [ this.name || "F", (+new Date()).toString(36) ].join("-"), 
                this.prefix + (this.fidx++).toString(36);
            }
        }
    }, $.fn.foundation = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        return this.each(function() {
            return Foundation.init.apply(Foundation, [ this ].concat(args)), this;
        });
    };
}(jQuery, window, window.document), function($, window, document) {
    "use strict";
    Foundation.libs.abide = {
        name: "abide",
        version: "5.4.7",
        settings: {
            live_validate: !0,
            focus_on_invalid: !0,
            error_labels: !0,
            error_class: "error",
            timeout: 1e3,
            patterns: {
                alpha: /^[a-zA-Z]+$/,
                alpha_numeric: /^[a-zA-Z0-9]+$/,
                integer: /^[-+]?\d+$/,
                number: /^[-+]?\d*(?:[\.\,]\d+)?$/,
                card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
                cvv: /^([0-9]){3,4}$/,
                email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,
                url: /^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,
                domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$/,
                datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
                date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
                time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
                dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
                month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
                day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,
                color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
            },
            validators: {
                equalTo: function(el) {
                    var from = document.getElementById(el.getAttribute(this.add_namespace("data-equalto"))).value, to = el.value, valid = from === to;
                    return valid;
                }
            }
        },
        timer: null,
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function(scope) {
            var self = this, form = self.S(scope).attr("novalidate", "novalidate"), settings = form.data(this.attr_name(!0) + "-init") || {};
            this.invalid_attr = this.add_namespace("data-invalid"), form.off(".abide").on("submit.fndtn.abide validate.fndtn.abide", function(e) {
                var is_ajax = /ajax/i.test(self.S(this).attr(self.attr_name()));
                return self.validate(self.S(this).find("input, textarea, select").get(), e, is_ajax);
            }).on("reset", function() {
                return self.reset($(this));
            }).find("input, textarea, select").off(".abide").on("blur.fndtn.abide change.fndtn.abide", function(e) {
                self.validate([ this ], e);
            }).on("keydown.fndtn.abide", function(e) {
                settings.live_validate === !0 && (clearTimeout(self.timer), self.timer = setTimeout(function() {
                    self.validate([ this ], e);
                }.bind(this), settings.timeout));
            });
        },
        reset: function(form) {
            form.removeAttr(this.invalid_attr), $(this.invalid_attr, form).removeAttr(this.invalid_attr), 
            $("." + this.settings.error_class, form).not("small").removeClass(this.settings.error_class);
        },
        validate: function(els, e, is_ajax) {
            for (var validations = this.parse_patterns(els), validation_count = validations.length, form = this.S(els[0]).closest("form"), submit_event = /submit/.test(e.type), i = 0; validation_count > i; i++) if (!validations[i] && (submit_event || is_ajax)) return this.settings.focus_on_invalid && els[i].focus(), 
            form.trigger("invalid"), this.S(els[i]).closest("form").attr(this.invalid_attr, ""), 
            !1;
            return (submit_event || is_ajax) && form.trigger("valid"), form.removeAttr(this.invalid_attr), 
            is_ajax ? !1 : !0;
        },
        parse_patterns: function(els) {
            for (var i = els.length, el_patterns = []; i--; ) el_patterns.push(this.pattern(els[i]));
            return this.check_validation_and_apply_styles(el_patterns);
        },
        pattern: function(el) {
            var type = el.getAttribute("type"), required = "string" == typeof el.getAttribute("required"), pattern = el.getAttribute("pattern") || "";
            return this.settings.patterns.hasOwnProperty(pattern) && pattern.length > 0 ? [ el, this.settings.patterns[pattern], required ] : pattern.length > 0 ? [ el, new RegExp(pattern), required ] : this.settings.patterns.hasOwnProperty(type) ? [ el, this.settings.patterns[type], required ] : (pattern = /.*/, 
            [ el, pattern, required ]);
        },
        check_validation_and_apply_styles: function(el_patterns) {
            var i = el_patterns.length, validations = [], form = this.S(el_patterns[0][0]).closest("[data-" + this.attr_name(!0) + "]");
            for (form.data(this.attr_name(!0) + "-init") || {}; i--; ) {
                var parent, valid, el = el_patterns[i][0], required = el_patterns[i][2], value = el.value.trim(), direct_parent = this.S(el).parent(), validator = el.getAttribute(this.add_namespace("data-abide-validator")), is_radio = "radio" === el.type, is_checkbox = "checkbox" === el.type, label = this.S('label[for="' + el.getAttribute("id") + '"]'), valid_length = required ? el.value.length > 0 : !0, el_validations = [];
                if (el.getAttribute(this.add_namespace("data-equalto")) && (validator = "equalTo"), 
                parent = direct_parent.is("label") ? direct_parent.parent() : direct_parent, validator && (valid = this.settings.validators[validator].apply(this, [ el, required, parent ]), 
                el_validations.push(valid)), is_radio && required) el_validations.push(this.valid_radio(el, required)); else if (is_checkbox && required) el_validations.push(this.valid_checkbox(el, required)); else if (el_validations.push(el_patterns[i][1].test(value) && valid_length || !required && el.value.length < 1 || $(el).attr("disabled") ? !0 : !1), 
                el_validations = [ el_validations.every(function(valid) {
                    return valid;
                }) ], el_validations[0]) this.S(el).removeAttr(this.invalid_attr), el.setAttribute("aria-invalid", "false"), 
                el.removeAttribute("aria-describedby"), parent.removeClass(this.settings.error_class), 
                label.length > 0 && this.settings.error_labels && label.removeClass(this.settings.error_class).removeAttr("role"), 
                $(el).triggerHandler("valid"); else {
                    this.S(el).attr(this.invalid_attr, ""), el.setAttribute("aria-invalid", "true");
                    var errorElem = parent.find("small." + this.settings.error_class, "span." + this.settings.error_class), errorID = errorElem.length > 0 ? errorElem[0].id : "";
                    errorID.length > 0 && el.setAttribute("aria-describedby", errorID), parent.addClass(this.settings.error_class), 
                    label.length > 0 && this.settings.error_labels && label.addClass(this.settings.error_class).attr("role", "alert"), 
                    $(el).triggerHandler("invalid");
                }
                validations.push(el_validations[0]);
            }
            return validations = [ validations.every(function(valid) {
                return valid;
            }) ];
        },
        valid_checkbox: function(el, required) {
            var el = this.S(el), valid = el.is(":checked") || !required;
            return valid ? el.removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class) : el.attr(this.invalid_attr, "").parent().addClass(this.settings.error_class), 
            valid;
        },
        valid_radio: function(el) {
            for (var name = el.getAttribute("name"), group = this.S(el).closest("[data-" + this.attr_name(!0) + "]").find("[name='" + name + "']"), count = group.length, valid = !1, i = 0; count > i; i++) group[i].checked && (valid = !0);
            for (var i = 0; count > i; i++) valid ? this.S(group[i]).removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class) : this.S(group[i]).attr(this.invalid_attr, "").parent().addClass(this.settings.error_class);
            return valid;
        },
        valid_equal: function(el, required, parent) {
            var from = document.getElementById(el.getAttribute(this.add_namespace("data-equalto"))).value, to = el.value, valid = from === to;
            return valid ? (this.S(el).removeAttr(this.invalid_attr), parent.removeClass(this.settings.error_class), 
            label.length > 0 && settings.error_labels && label.removeClass(this.settings.error_class)) : (this.S(el).attr(this.invalid_attr, ""), 
            parent.addClass(this.settings.error_class), label.length > 0 && settings.error_labels && label.addClass(this.settings.error_class)), 
            valid;
        },
        valid_oneof: function(el, required, parent, doNotValidateOthers) {
            var el = this.S(el), others = this.S("[" + this.add_namespace("data-oneof") + "]"), valid = others.filter(":checked").length > 0;
            if (valid ? el.removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class) : el.attr(this.invalid_attr, "").parent().addClass(this.settings.error_class), 
            !doNotValidateOthers) {
                var _this = this;
                others.each(function() {
                    _this.valid_oneof.call(_this, this, null, null, !0);
                });
            }
            return valid;
        }
    };
}(jQuery, window, window.document), function($) {
    "use strict";
    Foundation.libs.accordion = {
        name: "accordion",
        version: "5.4.7",
        settings: {
            content_class: "content",
            active_class: "active",
            multi_expand: !1,
            toggleable: !0,
            callback: function() {}
        },
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function() {
            var self = this, S = this.S;
            S(this.scope).off(".fndtn.accordion").on("click.fndtn.accordion", "[" + this.attr_name() + "] > dd > a", function(e) {
                var accordion = S(this).closest("[" + self.attr_name() + "]"), groupSelector = self.attr_name() + "=" + accordion.attr(self.attr_name()), settings = accordion.data(self.attr_name(!0) + "-init"), target = S("#" + this.href.split("#")[1]), aunts = $("> dd", accordion), siblings = aunts.children("." + settings.content_class), active_content = siblings.filter("." + settings.active_class);
                return e.preventDefault(), accordion.attr(self.attr_name()) && (siblings = siblings.add("[" + groupSelector + "] dd > ." + settings.content_class), 
                aunts = aunts.add("[" + groupSelector + "] dd")), settings.toggleable && target.is(active_content) ? (target.parent("dd").toggleClass(settings.active_class, !1), 
                target.toggleClass(settings.active_class, !1), settings.callback(target), target.triggerHandler("toggled", [ accordion ]), 
                void accordion.triggerHandler("toggled", [ target ])) : (settings.multi_expand || (siblings.removeClass(settings.active_class), 
                aunts.removeClass(settings.active_class)), target.addClass(settings.active_class).parent().addClass(settings.active_class), 
                settings.callback(target), target.triggerHandler("toggled", [ accordion ]), void accordion.triggerHandler("toggled", [ target ]));
            });
        },
        off: function() {},
        reflow: function() {}
    };
}(jQuery, window, window.document), function($) {
    "use strict";
    Foundation.libs.alert = {
        name: "alert",
        version: "5.4.7",
        settings: {
            callback: function() {}
        },
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function() {
            var self = this, S = this.S;
            $(this.scope).off(".alert").on("click.fndtn.alert", "[" + this.attr_name() + "] .close", function(e) {
                var alertBox = S(this).closest("[" + self.attr_name() + "]"), settings = alertBox.data(self.attr_name(!0) + "-init") || self.settings;
                e.preventDefault(), Modernizr.csstransitions ? (alertBox.addClass("alert-close"), 
                alertBox.on("transitionend webkitTransitionEnd oTransitionEnd", function() {
                    S(this).trigger("close").trigger("close.fndtn.alert").remove(), settings.callback();
                })) : alertBox.fadeOut(300, function() {
                    S(this).trigger("close").trigger("close.fndtn.alert").remove(), settings.callback();
                });
            });
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window, document, undefined) {
    "use strict";
    Foundation.libs.clearing = {
        name: "clearing",
        version: "5.4.7",
        settings: {
            templates: {
                viewing: '<a href="#" class="clearing-close">&times;</a><div class="visible-img" style="display: none"><div class="clearing-touch-label"></div><img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D" alt="" /><p class="clearing-caption"></p><a href="#" class="clearing-main-prev"><span></span></a><a href="#" class="clearing-main-next"><span></span></a></div>'
            },
            close_selectors: ".clearing-close, div.clearing-blackout",
            open_selectors: "",
            skip_selector: "",
            touch_label: "",
            init: !1,
            locked: !1
        },
        init: function(scope, method, options) {
            var self = this;
            Foundation.inherit(this, "throttle image_loaded"), this.bindings(method, options), 
            self.S(this.scope).is("[" + this.attr_name() + "]") ? this.assemble(self.S("li", this.scope)) : self.S("[" + this.attr_name() + "]", this.scope).each(function() {
                self.assemble(self.S("li", this));
            });
        },
        events: function(scope) {
            var self = this, S = self.S, $scroll_container = $(".scroll-container");
            $scroll_container.length > 0 && (this.scope = $scroll_container), S(this.scope).off(".clearing").on("click.fndtn.clearing", "ul[" + this.attr_name() + "] li " + this.settings.open_selectors, function(e, current, target) {
                var current = current || S(this), target = target || current, next = current.next("li"), settings = current.closest("[" + self.attr_name() + "]").data(self.attr_name(!0) + "-init"), image = S(e.target);
                e.preventDefault(), settings || (self.init(), settings = current.closest("[" + self.attr_name() + "]").data(self.attr_name(!0) + "-init")), 
                target.hasClass("visible") && current[0] === target[0] && next.length > 0 && self.is_open(current) && (target = next, 
                image = S("img", target)), self.open(image, current, target), self.update_paddles(target);
            }).on("click.fndtn.clearing", ".clearing-main-next", function(e) {
                self.nav(e, "next");
            }).on("click.fndtn.clearing", ".clearing-main-prev", function(e) {
                self.nav(e, "prev");
            }).on("click.fndtn.clearing", this.settings.close_selectors, function(e) {
                Foundation.libs.clearing.close(e, this);
            }), $(document).on("keydown.fndtn.clearing", function(e) {
                self.keydown(e);
            }), S(window).off(".clearing").on("resize.fndtn.clearing", function() {
                self.resize();
            }), this.swipe_events(scope);
        },
        swipe_events: function() {
            var self = this, S = self.S;
            S(this.scope).on("touchstart.fndtn.clearing", ".visible-img", function(e) {
                e.touches || (e = e.originalEvent);
                var data = {
                    start_page_x: e.touches[0].pageX,
                    start_page_y: e.touches[0].pageY,
                    start_time: new Date().getTime(),
                    delta_x: 0,
                    is_scrolling: undefined
                };
                S(this).data("swipe-transition", data), e.stopPropagation();
            }).on("touchmove.fndtn.clearing", ".visible-img", function(e) {
                if (e.touches || (e = e.originalEvent), !(e.touches.length > 1 || e.scale && 1 !== e.scale)) {
                    var data = S(this).data("swipe-transition");
                    if ("undefined" == typeof data && (data = {}), data.delta_x = e.touches[0].pageX - data.start_page_x, 
                    Foundation.rtl && (data.delta_x = -data.delta_x), "undefined" == typeof data.is_scrolling && (data.is_scrolling = !!(data.is_scrolling || Math.abs(data.delta_x) < Math.abs(e.touches[0].pageY - data.start_page_y))), 
                    !data.is_scrolling && !data.active) {
                        e.preventDefault();
                        var direction = data.delta_x < 0 ? "next" : "prev";
                        data.active = !0, self.nav(e, direction);
                    }
                }
            }).on("touchend.fndtn.clearing", ".visible-img", function(e) {
                S(this).data("swipe-transition", {}), e.stopPropagation();
            });
        },
        assemble: function($li) {
            var $el = $li.parent();
            if (!$el.parent().hasClass("carousel")) {
                $el.after('<div id="foundationClearingHolder"></div>');
                var grid = $el.detach(), grid_outerHTML = "";
                if (null != grid[0]) {
                    grid_outerHTML = grid[0].outerHTML;
                    var holder = this.S("#foundationClearingHolder"), settings = $el.data(this.attr_name(!0) + "-init"), data = {
                        grid: '<div class="carousel">' + grid_outerHTML + "</div>",
                        viewing: settings.templates.viewing
                    }, wrapper = '<div class="clearing-assembled"><div>' + data.viewing + data.grid + "</div></div>", touch_label = this.settings.touch_label;
                    Modernizr.touch && (wrapper = $(wrapper).find(".clearing-touch-label").html(touch_label).end()), 
                    holder.after(wrapper).remove();
                }
            }
        },
        open: function($image, current, target) {
            function startLoad() {
                setTimeout(function() {
                    this.image_loaded(image, function() {
                        1 !== image.outerWidth() || error ? cb.call(this, image) : startLoad.call(this);
                    }.bind(this));
                }.bind(this), 100);
            }
            function cb(image) {
                var $image = $(image);
                $image.css("visibility", "visible"), body.css("overflow", "hidden"), root.addClass("clearing-blackout"), 
                container.addClass("clearing-container"), visible_image.show(), this.fix_height(target).caption(self.S(".clearing-caption", visible_image), self.S("img", target)).center_and_label(image, label).shift(current, target, function() {
                    target.closest("li").siblings().removeClass("visible"), target.closest("li").addClass("visible");
                }), visible_image.trigger("opened.fndtn.clearing");
            }
            var self = this, body = $(document.body), root = target.closest(".clearing-assembled"), container = self.S("div", root).first(), visible_image = self.S(".visible-img", container), image = self.S("img", visible_image).not($image), label = self.S(".clearing-touch-label", container), error = !1;
            $("body").on("touchmove", function(e) {
                e.preventDefault();
            }), image.error(function() {
                error = !0;
            }), this.locked() || (visible_image.trigger("open.fndtn.clearing"), image.attr("src", this.load($image)).css("visibility", "hidden"), 
            startLoad.call(this));
        },
        close: function(e, el) {
            e.preventDefault();
            var container, visible_image, root = function(target) {
                return /blackout/.test(target.selector) ? target : target.closest(".clearing-blackout");
            }($(el)), body = $(document.body);
            return el === e.target && root && (body.css("overflow", ""), container = $("div", root).first(), 
            visible_image = $(".visible-img", container), visible_image.trigger("close.fndtn.clearing"), 
            this.settings.prev_index = 0, $("ul[" + this.attr_name() + "]", root).attr("style", "").closest(".clearing-blackout").removeClass("clearing-blackout"), 
            container.removeClass("clearing-container"), visible_image.hide(), visible_image.trigger("closed.fndtn.clearing")), 
            $("body").off("touchmove"), !1;
        },
        is_open: function(current) {
            return current.parent().prop("style").length > 0;
        },
        keydown: function(e) {
            var clearing = $(".clearing-blackout ul[" + this.attr_name() + "]"), NEXT_KEY = this.rtl ? 37 : 39, PREV_KEY = this.rtl ? 39 : 37, ESC_KEY = 27;
            e.which === NEXT_KEY && this.go(clearing, "next"), e.which === PREV_KEY && this.go(clearing, "prev"), 
            e.which === ESC_KEY && this.S("a.clearing-close").trigger("click").trigger("click.fndtn.clearing");
        },
        nav: function(e, direction) {
            var clearing = $("ul[" + this.attr_name() + "]", ".clearing-blackout");
            e.preventDefault(), this.go(clearing, direction);
        },
        resize: function() {
            var image = $("img", ".clearing-blackout .visible-img"), label = $(".clearing-touch-label", ".clearing-blackout");
            image.length && (this.center_and_label(image, label), image.trigger("resized.fndtn.clearing"));
        },
        fix_height: function(target) {
            var lis = target.parent().children(), self = this;
            return lis.each(function() {
                var li = self.S(this), image = li.find("img");
                li.height() > image.outerHeight() && li.addClass("fix-height");
            }).closest("ul").width(100 * lis.length + "%"), this;
        },
        update_paddles: function(target) {
            target = target.closest("li");
            var visible_image = target.closest(".carousel").siblings(".visible-img");
            target.next().length > 0 ? this.S(".clearing-main-next", visible_image).removeClass("disabled") : this.S(".clearing-main-next", visible_image).addClass("disabled"), 
            target.prev().length > 0 ? this.S(".clearing-main-prev", visible_image).removeClass("disabled") : this.S(".clearing-main-prev", visible_image).addClass("disabled");
        },
        center_and_label: function(target, label) {
            return this.rtl ? (target.css({
                marginRight: -(target.outerWidth() / 2),
                marginTop: -(target.outerHeight() / 2),
                left: "auto",
                right: "50%"
            }), label.length > 0 && label.css({
                marginRight: -(label.outerWidth() / 2),
                marginTop: -(target.outerHeight() / 2) - label.outerHeight() - 10,
                left: "auto",
                right: "50%"
            })) : (target.css({
                marginLeft: -(target.outerWidth() / 2),
                marginTop: -(target.outerHeight() / 2)
            }), label.length > 0 && label.css({
                marginLeft: -(label.outerWidth() / 2),
                marginTop: -(target.outerHeight() / 2) - label.outerHeight() - 10
            })), this;
        },
        load: function($image) {
            var href;
            return href = "A" === $image[0].nodeName ? $image.attr("href") : $image.parent().attr("href"), 
            this.preload($image), href ? href : $image.attr("src");
        },
        preload: function($image) {
            this.img($image.closest("li").next()).img($image.closest("li").prev());
        },
        img: function(img) {
            if (img.length) {
                var new_img = new Image(), new_a = this.S("a", img);
                new_img.src = new_a.length ? new_a.attr("href") : this.S("img", img).attr("src");
            }
            return this;
        },
        caption: function(container, $image) {
            var caption = $image.attr("data-caption");
            return caption ? container.html(caption).show() : container.text("").hide(), this;
        },
        go: function($ul, direction) {
            var current = this.S(".visible", $ul), target = current[direction]();
            this.settings.skip_selector && 0 != target.find(this.settings.skip_selector).length && (target = target[direction]()), 
            target.length && this.S("img", target).trigger("click", [ current, target ]).trigger("click.fndtn.clearing", [ current, target ]).trigger("change.fndtn.clearing");
        },
        shift: function(current, target, callback) {
            var skip_shift, clearing = target.parent(), old_index = this.settings.prev_index || target.index(), direction = this.direction(clearing, current, target), dir = this.rtl ? "right" : "left", left = parseInt(clearing.css("left"), 10), width = target.outerWidth(), dir_obj = {};
            target.index() === old_index || /skip/.test(direction) ? /skip/.test(direction) && (skip_shift = target.index() - this.settings.up_count, 
            this.lock(), skip_shift > 0 ? (dir_obj[dir] = -(skip_shift * width), clearing.animate(dir_obj, 300, this.unlock())) : (dir_obj[dir] = 0, 
            clearing.animate(dir_obj, 300, this.unlock()))) : /left/.test(direction) ? (this.lock(), 
            dir_obj[dir] = left + width, clearing.animate(dir_obj, 300, this.unlock())) : /right/.test(direction) && (this.lock(), 
            dir_obj[dir] = left - width, clearing.animate(dir_obj, 300, this.unlock())), callback();
        },
        direction: function($el, current, target) {
            var response, lis = this.S("li", $el), li_width = lis.outerWidth() + lis.outerWidth() / 4, up_count = Math.floor(this.S(".clearing-container").outerWidth() / li_width) - 1, target_index = lis.index(target);
            return this.settings.up_count = up_count, response = this.adjacent(this.settings.prev_index, target_index) ? target_index > up_count && target_index > this.settings.prev_index ? "right" : target_index > up_count - 1 && target_index <= this.settings.prev_index ? "left" : !1 : "skip", 
            this.settings.prev_index = target_index, response;
        },
        adjacent: function(current_index, target_index) {
            for (var i = target_index + 1; i >= target_index - 1; i--) if (i === current_index) return !0;
            return !1;
        },
        lock: function() {
            this.settings.locked = !0;
        },
        unlock: function() {
            this.settings.locked = !1;
        },
        locked: function() {
            return this.settings.locked;
        },
        off: function() {
            this.S(this.scope).off(".fndtn.clearing"), this.S(window).off(".fndtn.clearing");
        },
        reflow: function() {
            this.init();
        }
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs.dropdown = {
        name: "dropdown",
        version: "5.4.7",
        settings: {
            active_class: "open",
            disabled_class: "disabled",
            mega_class: "mega",
            align: "bottom",
            is_hover: !1,
            opened: function() {},
            closed: function() {}
        },
        init: function(scope, method, options) {
            Foundation.inherit(this, "throttle"), this.bindings(method, options);
        },
        events: function() {
            var self = this, S = self.S;
            S(this.scope).off(".dropdown").on("click.fndtn.dropdown", "[" + this.attr_name() + "]", function(e) {
                var settings = S(this).data(self.attr_name(!0) + "-init") || self.settings;
                (!settings.is_hover || Modernizr.touch) && (e.preventDefault(), self.toggle($(this)));
            }).on("mouseenter.fndtn.dropdown", "[" + this.attr_name() + "], [" + this.attr_name() + "-content]", function(e) {
                var dropdown, target, $this = S(this);
                clearTimeout(self.timeout), $this.data(self.data_attr()) ? (dropdown = S("#" + $this.data(self.data_attr())), 
                target = $this) : (dropdown = $this, target = S("[" + self.attr_name() + "='" + dropdown.attr("id") + "']"));
                var settings = target.data(self.attr_name(!0) + "-init") || self.settings;
                S(e.target).data(self.data_attr()) && settings.is_hover && self.closeall.call(self), 
                settings.is_hover && self.open.apply(self, [ dropdown, target ]);
            }).on("mouseleave.fndtn.dropdown", "[" + this.attr_name() + "], [" + this.attr_name() + "-content]", function() {
                var $this = S(this);
                self.timeout = setTimeout(function() {
                    if ($this.data(self.data_attr())) {
                        var settings = $this.data(self.data_attr(!0) + "-init") || self.settings;
                        settings.is_hover && self.close.call(self, S("#" + $this.data(self.data_attr())));
                    } else {
                        var target = S("[" + self.attr_name() + '="' + S(this).attr("id") + '"]'), settings = target.data(self.attr_name(!0) + "-init") || self.settings;
                        settings.is_hover && self.close.call(self, $this);
                    }
                }.bind(this), 150);
            }).on("click.fndtn.dropdown", function(e) {
                var parent = S(e.target).closest("[" + self.attr_name() + "-content]");
                if (!(S(e.target).closest("[" + self.attr_name() + "]").length > 0)) return !S(e.target).data("revealId") && parent.length > 0 && (S(e.target).is("[" + self.attr_name() + "-content]") || $.contains(parent.first()[0], e.target)) ? void e.stopPropagation() : void self.close.call(self, S("[" + self.attr_name() + "-content]"));
            }).on("opened.fndtn.dropdown", "[" + self.attr_name() + "-content]", function() {
                self.settings.opened.call(this);
            }).on("closed.fndtn.dropdown", "[" + self.attr_name() + "-content]", function() {
                self.settings.closed.call(this);
            }), S(window).off(".dropdown").on("resize.fndtn.dropdown", self.throttle(function() {
                self.resize.call(self);
            }, 50)), this.resize();
        },
        close: function(dropdown) {
            var self = this;
            dropdown.each(function() {
                var original_target = $("[" + self.attr_name() + "=" + dropdown[0].id + "]") || $("aria-controls=" + dropdown[0].id + "]");
                original_target.attr("aria-expanded", "false"), self.S(this).hasClass(self.settings.active_class) && (self.S(this).css(Foundation.rtl ? "right" : "left", "-99999px").attr("aria-hidden", "true").removeClass(self.settings.active_class).prev("[" + self.attr_name() + "]").removeClass(self.settings.active_class).removeData("target"), 
                self.S(this).trigger("closed").trigger("closed.fndtn.dropdown", [ dropdown ]));
            });
        },
        closeall: function() {
            var self = this;
            $.each(self.S("[" + this.attr_name() + "-content]"), function() {
                self.close.call(self, self.S(this));
            });
        },
        open: function(dropdown, target) {
            this.css(dropdown.addClass(this.settings.active_class), target), dropdown.prev("[" + this.attr_name() + "]").addClass(this.settings.active_class), 
            dropdown.data("target", target.get(0)).trigger("opened").trigger("opened.fndtn.dropdown", [ dropdown, target ]), 
            dropdown.attr("aria-hidden", "false"), target.attr("aria-expanded", "true"), dropdown.focus();
        },
        data_attr: function() {
            return this.namespace.length > 0 ? this.namespace + "-" + this.name : this.name;
        },
        toggle: function(target) {
            if (!target.hasClass(this.settings.disabled_class)) {
                var dropdown = this.S("#" + target.data(this.data_attr()));
                0 !== dropdown.length && (this.close.call(this, this.S("[" + this.attr_name() + "-content]").not(dropdown)), 
                dropdown.hasClass(this.settings.active_class) ? (this.close.call(this, dropdown), 
                dropdown.data("target") !== target.get(0) && this.open.call(this, dropdown, target)) : this.open.call(this, dropdown, target));
            }
        },
        resize: function() {
            var dropdown = this.S("[" + this.attr_name() + "-content].open"), target = this.S("[" + this.attr_name() + "='" + dropdown.attr("id") + "']");
            dropdown.length && target.length && this.css(dropdown, target);
        },
        css: function(dropdown, target) {
            var left_offset = Math.max((target.width() - dropdown.width()) / 2, 8), settings = target.data(this.attr_name(!0) + "-init") || this.settings;
            if (this.clear_idx(), this.small()) {
                var p = this.dirs.bottom.call(dropdown, target, settings);
                dropdown.attr("style", "").removeClass("drop-left drop-right drop-top").css({
                    position: "absolute",
                    width: "95%",
                    "max-width": "none",
                    top: p.top
                }), dropdown.css(Foundation.rtl ? "right" : "left", left_offset);
            } else this.style(dropdown, target, settings);
            return dropdown;
        },
        style: function(dropdown, target, settings) {
            var css = $.extend({
                position: "absolute"
            }, this.dirs[settings.align].call(dropdown, target, settings));
            dropdown.attr("style", "").css(css);
        },
        dirs: {
            _base: function(t) {
                var o_p = this.offsetParent(), o = o_p.offset(), p = t.offset();
                return p.top -= o.top, p.left -= o.left, p;
            },
            top: function(t, s) {
                var self = Foundation.libs.dropdown, p = self.dirs._base.call(this, t);
                return this.addClass("drop-top"), (t.outerWidth() < this.outerWidth() || self.small() || this.hasClass(s.mega_menu)) && self.adjust_pip(this, t, s, p), 
                Foundation.rtl ? {
                    left: p.left - this.outerWidth() + t.outerWidth(),
                    top: p.top - this.outerHeight()
                } : {
                    left: p.left,
                    top: p.top - this.outerHeight()
                };
            },
            bottom: function(t, s) {
                var self = Foundation.libs.dropdown, p = self.dirs._base.call(this, t);
                return (t.outerWidth() < this.outerWidth() || self.small() || this.hasClass(s.mega_menu)) && self.adjust_pip(this, t, s, p), 
                self.rtl ? {
                    left: p.left - this.outerWidth() + t.outerWidth(),
                    top: p.top + t.outerHeight()
                } : {
                    left: p.left,
                    top: p.top + t.outerHeight()
                };
            },
            left: function(t) {
                var p = Foundation.libs.dropdown.dirs._base.call(this, t);
                return this.addClass("drop-left"), {
                    left: p.left - this.outerWidth(),
                    top: p.top
                };
            },
            right: function(t) {
                var p = Foundation.libs.dropdown.dirs._base.call(this, t);
                return this.addClass("drop-right"), {
                    left: p.left + t.outerWidth(),
                    top: p.top
                };
            }
        },
        adjust_pip: function(dropdown, target, settings, position) {
            var sheet = Foundation.stylesheet, pip_offset_base = 8;
            dropdown.hasClass(settings.mega_class) ? pip_offset_base = position.left + target.outerWidth() / 2 - 8 : this.small() && (pip_offset_base += position.left - 8), 
            this.rule_idx = sheet.cssRules.length;
            var sel_before = ".f-dropdown.open:before", sel_after = ".f-dropdown.open:after", css_before = "left: " + pip_offset_base + "px;", css_after = "left: " + (pip_offset_base - 1) + "px;";
            sheet.insertRule ? (sheet.insertRule([ sel_before, "{", css_before, "}" ].join(" "), this.rule_idx), 
            sheet.insertRule([ sel_after, "{", css_after, "}" ].join(" "), this.rule_idx + 1)) : (sheet.addRule(sel_before, css_before, this.rule_idx), 
            sheet.addRule(sel_after, css_after, this.rule_idx + 1));
        },
        clear_idx: function() {
            var sheet = Foundation.stylesheet;
            "undefined" != typeof this.rule_idx && (sheet.deleteRule(this.rule_idx), sheet.deleteRule(this.rule_idx), 
            delete this.rule_idx);
        },
        small: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },
        off: function() {
            this.S(this.scope).off(".fndtn.dropdown"), this.S("html, body").off(".fndtn.dropdown"), 
            this.S(window).off(".fndtn.dropdown"), this.S("[data-dropdown-content]").off(".fndtn.dropdown");
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs.equalizer = {
        name: "equalizer",
        version: "5.4.7",
        settings: {
            use_tallest: !0,
            before_height_change: $.noop,
            after_height_change: $.noop,
            equalize_on_stack: !1
        },
        init: function(scope, method, options) {
            Foundation.inherit(this, "image_loaded"), this.bindings(method, options), this.reflow();
        },
        events: function() {
            this.S(window).off(".equalizer").on("resize.fndtn.equalizer", function() {
                this.reflow();
            }.bind(this));
        },
        equalize: function(equalizer) {
            var isStacked = !1, vals = equalizer.find("[" + this.attr_name() + "-watch]:visible"), settings = equalizer.data(this.attr_name(!0) + "-init");
            if (0 !== vals.length) {
                var firstTopOffset = vals.first().offset().top;
                if (settings.before_height_change(), equalizer.trigger("before-height-change").trigger("before-height-change.fndth.equalizer"), 
                vals.height("inherit"), vals.each(function() {
                    var el = $(this);
                    el.offset().top !== firstTopOffset && (isStacked = !0);
                }), settings.equalize_on_stack !== !1 || !isStacked) {
                    var heights = vals.map(function() {
                        return $(this).outerHeight(!1);
                    }).get();
                    if (settings.use_tallest) {
                        var max = Math.max.apply(null, heights);
                        vals.css("height", max);
                    } else {
                        var min = Math.min.apply(null, heights);
                        vals.css("height", min);
                    }
                    settings.after_height_change(), equalizer.trigger("after-height-change").trigger("after-height-change.fndtn.equalizer");
                }
            }
        },
        reflow: function() {
            var self = this;
            this.S("[" + this.attr_name() + "]", this.scope).each(function() {
                var $eq_target = $(this);
                self.image_loaded(self.S("img", this), function() {
                    self.equalize($eq_target);
                });
            });
        }
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs.interchange = {
        name: "interchange",
        version: "5.4.7",
        cache: {},
        images_loaded: !1,
        nodes_loaded: !1,
        settings: {
            load_attr: "interchange",
            named_queries: {
                "default": "only screen",
                small: Foundation.media_queries.small,
                medium: Foundation.media_queries.medium,
                large: Foundation.media_queries.large,
                xlarge: Foundation.media_queries.xlarge,
                xxlarge: Foundation.media_queries.xxlarge,
                landscape: "only screen and (orientation: landscape)",
                portrait: "only screen and (orientation: portrait)",
                retina: "only screen and (-webkit-min-device-pixel-ratio: 2),only screen and (min--moz-device-pixel-ratio: 2),only screen and (-o-min-device-pixel-ratio: 2/1),only screen and (min-device-pixel-ratio: 2),only screen and (min-resolution: 192dpi),only screen and (min-resolution: 2dppx)"
            },
            directives: {
                replace: function(el, path, trigger) {
                    if (/IMG/.test(el[0].nodeName)) {
                        var orig_path = el[0].src;
                        if (new RegExp(path, "i").test(orig_path)) return;
                        return el[0].src = path, trigger(el[0].src);
                    }
                    var last_path = el.data(this.data_attr + "-last-path"), self = this;
                    if (last_path != path) return /\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i.test(path) ? ($(el).css("background-image", "url(" + path + ")"), 
                    el.data("interchange-last-path", path), trigger(path)) : $.get(path, function(response) {
                        el.html(response), el.data(self.data_attr + "-last-path", path), trigger();
                    });
                }
            }
        },
        init: function(scope, method, options) {
            Foundation.inherit(this, "throttle random_str"), this.data_attr = this.set_data_attr(), 
            $.extend(!0, this.settings, method, options), this.bindings(method, options), this.load("images"), 
            this.load("nodes");
        },
        get_media_hash: function() {
            var mediaHash = "";
            for (var queryName in this.settings.named_queries) mediaHash += matchMedia(this.settings.named_queries[queryName]).matches.toString();
            return mediaHash;
        },
        events: function() {
            var prevMediaHash, self = this;
            return $(window).off(".interchange").on("resize.fndtn.interchange", self.throttle(function() {
                var currMediaHash = self.get_media_hash();
                currMediaHash !== prevMediaHash && self.resize(), prevMediaHash = currMediaHash;
            }, 50)), this;
        },
        resize: function() {
            var cache = this.cache;
            if (!this.images_loaded || !this.nodes_loaded) return void setTimeout($.proxy(this.resize, this), 50);
            for (var uuid in cache) if (cache.hasOwnProperty(uuid)) {
                var passed = this.results(uuid, cache[uuid]);
                passed && this.settings.directives[passed.scenario[1]].call(this, passed.el, passed.scenario[0], function() {
                    if (arguments[0] instanceof Array) var args = arguments[0]; else var args = Array.prototype.slice.call(arguments, 0);
                    passed.el.trigger(passed.scenario[1], args);
                });
            }
        },
        results: function(uuid, scenarios) {
            var count = scenarios.length;
            if (count > 0) for (var el = this.S("[" + this.add_namespace("data-uuid") + '="' + uuid + '"]'); count--; ) {
                var mq, rule = scenarios[count][2];
                if (mq = matchMedia(this.settings.named_queries.hasOwnProperty(rule) ? this.settings.named_queries[rule] : rule), 
                mq.matches) return {
                    el: el,
                    scenario: scenarios[count]
                };
            }
            return !1;
        },
        load: function(type, force_update) {
            return ("undefined" == typeof this["cached_" + type] || force_update) && this["update_" + type](), 
            this["cached_" + type];
        },
        update_images: function() {
            var images = this.S("img[" + this.data_attr + "]"), count = images.length, i = count, loaded_count = 0, data_attr = this.data_attr;
            for (this.cache = {}, this.cached_images = [], this.images_loaded = 0 === count; i--; ) {
                if (loaded_count++, images[i]) {
                    var str = images[i].getAttribute(data_attr) || "";
                    str.length > 0 && this.cached_images.push(images[i]);
                }
                loaded_count === count && (this.images_loaded = !0, this.enhance("images"));
            }
            return this;
        },
        update_nodes: function() {
            var nodes = this.S("[" + this.data_attr + "]").not("img"), count = nodes.length, i = count, loaded_count = 0, data_attr = this.data_attr;
            for (this.cached_nodes = [], this.nodes_loaded = 0 === count; i--; ) {
                loaded_count++;
                var str = nodes[i].getAttribute(data_attr) || "";
                str.length > 0 && this.cached_nodes.push(nodes[i]), loaded_count === count && (this.nodes_loaded = !0, 
                this.enhance("nodes"));
            }
            return this;
        },
        enhance: function(type) {
            for (var i = this["cached_" + type].length; i--; ) this.object($(this["cached_" + type][i]));
            return $(window).trigger("resize").trigger("resize.fndtn.interchange");
        },
        convert_directive: function(directive) {
            var trimmed = this.trim(directive);
            return trimmed.length > 0 ? trimmed : "replace";
        },
        parse_scenario: function(scenario) {
            var directive_match = scenario[0].match(/(.+),\s*(\w+)\s*$/), media_query = scenario[1];
            if (directive_match) var path = directive_match[1], directive = directive_match[2]; else var cached_split = scenario[0].split(/,\s*$/), path = cached_split[0], directive = "";
            return [ this.trim(path), this.convert_directive(directive), this.trim(media_query) ];
        },
        object: function(el) {
            var raw_arr = this.parse_data_attr(el), scenarios = [], i = raw_arr.length;
            if (i > 0) for (;i--; ) {
                var split = raw_arr[i].split(/\((.*?)(\))$/);
                if (split.length > 1) {
                    var params = this.parse_scenario(split);
                    scenarios.push(params);
                }
            }
            return this.store(el, scenarios);
        },
        store: function(el, scenarios) {
            var uuid = this.random_str(), current_uuid = el.data(this.add_namespace("uuid", !0));
            return this.cache[current_uuid] ? this.cache[current_uuid] : (el.attr(this.add_namespace("data-uuid"), uuid), 
            this.cache[uuid] = scenarios);
        },
        trim: function(str) {
            return "string" == typeof str ? $.trim(str) : str;
        },
        set_data_attr: function(init) {
            return init ? this.namespace.length > 0 ? this.namespace + "-" + this.settings.load_attr : this.settings.load_attr : this.namespace.length > 0 ? "data-" + this.namespace + "-" + this.settings.load_attr : "data-" + this.settings.load_attr;
        },
        parse_data_attr: function(el) {
            for (var raw = el.attr(this.attr_name()).split(/\[(.*?)\]/), i = raw.length, output = []; i--; ) raw[i].replace(/[\W\d]+/, "").length > 4 && output.push(raw[i]);
            return output;
        },
        reflow: function() {
            this.load("images", !0), this.load("nodes", !0);
        }
    };
}(jQuery, window, window.document), function($, window, document, undefined) {
    "use strict";
    Foundation.libs.joyride = {
        name: "joyride",
        version: "5.4.7",
        defaults: {
            expose: !1,
            modal: !0,
            keyboard: !0,
            tip_location: "bottom",
            nub_position: "auto",
            scroll_speed: 1500,
            scroll_animation: "linear",
            timer: 0,
            start_timer_on_click: !0,
            start_offset: 0,
            next_button: !0,
            prev_button: !0,
            tip_animation: "fade",
            pause_after: [],
            exposed: [],
            tip_animation_fade_speed: 300,
            cookie_monster: !1,
            cookie_name: "joyride",
            cookie_domain: !1,
            cookie_expires: 365,
            tip_container: "body",
            abort_on_close: !0,
            tip_location_patterns: {
                top: [ "bottom" ],
                bottom: [],
                left: [ "right", "top", "bottom" ],
                right: [ "left", "top", "bottom" ]
            },
            post_ride_callback: function() {},
            post_step_callback: function() {},
            pre_step_callback: function() {},
            pre_ride_callback: function() {},
            post_expose_callback: function() {},
            template: {
                link: '<a href="#close" class="joyride-close-tip">&times;</a>',
                timer: '<div class="joyride-timer-indicator-wrap"><span class="joyride-timer-indicator"></span></div>',
                tip: '<div class="joyride-tip-guide"><span class="joyride-nub"></span></div>',
                wrapper: '<div class="joyride-content-wrapper"></div>',
                button: '<a href="#" class="small button joyride-next-tip"></a>',
                prev_button: '<a href="#" class="small button joyride-prev-tip"></a>',
                modal: '<div class="joyride-modal-bg"></div>',
                expose: '<div class="joyride-expose-wrapper"></div>',
                expose_cover: '<div class="joyride-expose-cover"></div>'
            },
            expose_add_class: ""
        },
        init: function(scope, method, options) {
            Foundation.inherit(this, "throttle random_str"), this.settings = this.settings || $.extend({}, this.defaults, options || method), 
            this.bindings(method, options);
        },
        go_next: function() {
            this.settings.$li.next().length < 1 ? this.end() : this.settings.timer > 0 ? (clearTimeout(this.settings.automate), 
            this.hide(), this.show(), this.startTimer()) : (this.hide(), this.show());
        },
        go_prev: function() {
            this.settings.$li.prev().length < 1 || (this.settings.timer > 0 ? (clearTimeout(this.settings.automate), 
            this.hide(), this.show(null, !0), this.startTimer()) : (this.hide(), this.show(null, !0)));
        },
        events: function() {
            var self = this;
            $(this.scope).off(".joyride").on("click.fndtn.joyride", ".joyride-next-tip, .joyride-modal-bg", function(e) {
                e.preventDefault(), this.go_next();
            }.bind(this)).on("click.fndtn.joyride", ".joyride-prev-tip", function(e) {
                e.preventDefault(), this.go_prev();
            }.bind(this)).on("click.fndtn.joyride", ".joyride-close-tip", function(e) {
                e.preventDefault(), this.end(this.settings.abort_on_close);
            }.bind(this)).on("keyup.fndtn.joyride", function(e) {
                if (this.settings.keyboard && this.settings.riding) switch (e.which) {
                  case 39:
                    e.preventDefault(), this.go_next();
                    break;

                  case 37:
                    e.preventDefault(), this.go_prev();
                    break;

                  case 27:
                    e.preventDefault(), this.end(this.settings.abort_on_close);
                }
            }.bind(this)), $(window).off(".joyride").on("resize.fndtn.joyride", self.throttle(function() {
                if ($("[" + self.attr_name() + "]").length > 0 && self.settings.$next_tip && self.settings.riding) {
                    if (self.settings.exposed.length > 0) {
                        var $els = $(self.settings.exposed);
                        $els.each(function() {
                            var $this = $(this);
                            self.un_expose($this), self.expose($this);
                        });
                    }
                    self.is_phone() ? self.pos_phone() : self.pos_default(!1);
                }
            }, 100));
        },
        start: function() {
            var self = this, $this = $("[" + this.attr_name() + "]", this.scope), integer_settings = [ "timer", "scrollSpeed", "startOffset", "tipAnimationFadeSpeed", "cookieExpires" ], int_settings_count = integer_settings.length;
            !$this.length > 0 || (this.settings.init || this.events(), this.settings = $this.data(this.attr_name(!0) + "-init"), 
            this.settings.$content_el = $this, this.settings.$body = $(this.settings.tip_container), 
            this.settings.body_offset = $(this.settings.tip_container).position(), this.settings.$tip_content = this.settings.$content_el.find("> li"), 
            this.settings.paused = !1, this.settings.attempts = 0, this.settings.riding = !0, 
            "function" != typeof $.cookie && (this.settings.cookie_monster = !1), (!this.settings.cookie_monster || this.settings.cookie_monster && !$.cookie(this.settings.cookie_name)) && (this.settings.$tip_content.each(function(index) {
                var $this = $(this);
                this.settings = $.extend({}, self.defaults, self.data_options($this));
                for (var i = int_settings_count; i--; ) self.settings[integer_settings[i]] = parseInt(self.settings[integer_settings[i]], 10);
                self.create({
                    $li: $this,
                    index: index
                });
            }), !this.settings.start_timer_on_click && this.settings.timer > 0 ? (this.show("init"), 
            this.startTimer()) : this.show("init")));
        },
        resume: function() {
            this.set_li(), this.show();
        },
        tip_template: function(opts) {
            var $blank, content;
            return opts.tip_class = opts.tip_class || "", $blank = $(this.settings.template.tip).addClass(opts.tip_class), 
            content = $.trim($(opts.li).html()) + this.prev_button_text(opts.prev_button_text, opts.index) + this.button_text(opts.button_text) + this.settings.template.link + this.timer_instance(opts.index), 
            $blank.append($(this.settings.template.wrapper)), $blank.first().attr(this.add_namespace("data-index"), opts.index), 
            $(".joyride-content-wrapper", $blank).append(content), $blank[0];
        },
        timer_instance: function(index) {
            var txt;
            return txt = 0 === index && this.settings.start_timer_on_click && this.settings.timer > 0 || 0 === this.settings.timer ? "" : $(this.settings.template.timer)[0].outerHTML;
        },
        button_text: function(txt) {
            return this.settings.tip_settings.next_button ? (txt = $.trim(txt) || "Next", txt = $(this.settings.template.button).append(txt)[0].outerHTML) : txt = "", 
            txt;
        },
        prev_button_text: function(txt, idx) {
            return this.settings.tip_settings.prev_button ? (txt = $.trim(txt) || "Previous", 
            txt = 0 == idx ? $(this.settings.template.prev_button).append(txt).addClass("disabled")[0].outerHTML : $(this.settings.template.prev_button).append(txt)[0].outerHTML) : txt = "", 
            txt;
        },
        create: function(opts) {
            this.settings.tip_settings = $.extend({}, this.settings, this.data_options(opts.$li));
            var buttonText = opts.$li.attr(this.add_namespace("data-button")) || opts.$li.attr(this.add_namespace("data-text")), prevButtonText = opts.$li.attr(this.add_namespace("data-button-prev")) || opts.$li.attr(this.add_namespace("data-prev-text")), tipClass = opts.$li.attr("class"), $tip_content = $(this.tip_template({
                tip_class: tipClass,
                index: opts.index,
                button_text: buttonText,
                prev_button_text: prevButtonText,
                li: opts.$li
            }));
            $(this.settings.tip_container).append($tip_content);
        },
        show: function(init, is_prev) {
            var $timer = null;
            this.settings.$li === undefined || -1 === $.inArray(this.settings.$li.index(), this.settings.pause_after) ? (this.settings.paused ? this.settings.paused = !1 : this.set_li(init, is_prev), 
            this.settings.attempts = 0, this.settings.$li.length && this.settings.$target.length > 0 ? (init && (this.settings.pre_ride_callback(this.settings.$li.index(), this.settings.$next_tip), 
            this.settings.modal && this.show_modal()), this.settings.pre_step_callback(this.settings.$li.index(), this.settings.$next_tip), 
            this.settings.modal && this.settings.expose && this.expose(), this.settings.tip_settings = $.extend({}, this.settings, this.data_options(this.settings.$li)), 
            this.settings.timer = parseInt(this.settings.timer, 10), this.settings.tip_settings.tip_location_pattern = this.settings.tip_location_patterns[this.settings.tip_settings.tip_location], 
            /body/i.test(this.settings.$target.selector) || this.scroll_to(), this.is_phone() ? this.pos_phone(!0) : this.pos_default(!0), 
            $timer = this.settings.$next_tip.find(".joyride-timer-indicator"), /pop/i.test(this.settings.tip_animation) ? ($timer.width(0), 
            this.settings.timer > 0 ? (this.settings.$next_tip.show(), setTimeout(function() {
                $timer.animate({
                    width: $timer.parent().width()
                }, this.settings.timer, "linear");
            }.bind(this), this.settings.tip_animation_fade_speed)) : this.settings.$next_tip.show()) : /fade/i.test(this.settings.tip_animation) && ($timer.width(0), 
            this.settings.timer > 0 ? (this.settings.$next_tip.fadeIn(this.settings.tip_animation_fade_speed).show(), 
            setTimeout(function() {
                $timer.animate({
                    width: $timer.parent().width()
                }, this.settings.timer, "linear");
            }.bind(this), this.settings.tip_animation_fade_speed)) : this.settings.$next_tip.fadeIn(this.settings.tip_animation_fade_speed)), 
            this.settings.$current_tip = this.settings.$next_tip) : this.settings.$li && this.settings.$target.length < 1 ? this.show(init, is_prev) : this.end()) : this.settings.paused = !0;
        },
        is_phone: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },
        hide: function() {
            this.settings.modal && this.settings.expose && this.un_expose(), this.settings.modal || $(".joyride-modal-bg").hide(), 
            this.settings.$current_tip.css("visibility", "hidden"), setTimeout($.proxy(function() {
                this.hide(), this.css("visibility", "visible");
            }, this.settings.$current_tip), 0), this.settings.post_step_callback(this.settings.$li.index(), this.settings.$current_tip);
        },
        set_li: function(init, is_prev) {
            init ? (this.settings.$li = this.settings.$tip_content.eq(this.settings.start_offset), 
            this.set_next_tip(), this.settings.$current_tip = this.settings.$next_tip) : (this.settings.$li = is_prev ? this.settings.$li.prev() : this.settings.$li.next(), 
            this.set_next_tip()), this.set_target();
        },
        set_next_tip: function() {
            this.settings.$next_tip = $(".joyride-tip-guide").eq(this.settings.$li.index()), 
            this.settings.$next_tip.data("closed", "");
        },
        set_target: function() {
            var cl = this.settings.$li.attr(this.add_namespace("data-class")), id = this.settings.$li.attr(this.add_namespace("data-id")), $sel = function() {
                return id ? $(document.getElementById(id)) : cl ? $("." + cl).first() : $("body");
            };
            this.settings.$target = $sel();
        },
        scroll_to: function() {
            var window_half, tipOffset;
            window_half = $(window).height() / 2, tipOffset = Math.ceil(this.settings.$target.offset().top - window_half + this.settings.$next_tip.outerHeight()), 
            0 != tipOffset && $("html, body").stop().animate({
                scrollTop: tipOffset
            }, this.settings.scroll_speed, "swing");
        },
        paused: function() {
            return -1 === $.inArray(this.settings.$li.index() + 1, this.settings.pause_after);
        },
        restart: function() {
            this.hide(), this.settings.$li = undefined, this.show("init");
        },
        pos_default: function(init) {
            var $nub = this.settings.$next_tip.find(".joyride-nub"), nub_width = Math.ceil($nub.outerWidth() / 2), nub_height = Math.ceil($nub.outerHeight() / 2), toggle = init || !1;
            if (toggle && (this.settings.$next_tip.css("visibility", "hidden"), this.settings.$next_tip.show()), 
            /body/i.test(this.settings.$target.selector)) this.settings.$li.length && this.pos_modal($nub); else {
                var topAdjustment = this.settings.tip_settings.tipAdjustmentY ? parseInt(this.settings.tip_settings.tipAdjustmentY) : 0, leftAdjustment = this.settings.tip_settings.tipAdjustmentX ? parseInt(this.settings.tip_settings.tipAdjustmentX) : 0;
                this.bottom() ? (this.settings.$next_tip.css(this.rtl ? {
                    top: this.settings.$target.offset().top + nub_height + this.settings.$target.outerHeight() + topAdjustment,
                    left: this.settings.$target.offset().left + this.settings.$target.outerWidth() - this.settings.$next_tip.outerWidth() + leftAdjustment
                } : {
                    top: this.settings.$target.offset().top + nub_height + this.settings.$target.outerHeight() + topAdjustment,
                    left: this.settings.$target.offset().left + leftAdjustment
                }), this.nub_position($nub, this.settings.tip_settings.nub_position, "top")) : this.top() ? (this.settings.$next_tip.css(this.rtl ? {
                    top: this.settings.$target.offset().top - this.settings.$next_tip.outerHeight() - nub_height + topAdjustment,
                    left: this.settings.$target.offset().left + this.settings.$target.outerWidth() - this.settings.$next_tip.outerWidth()
                } : {
                    top: this.settings.$target.offset().top - this.settings.$next_tip.outerHeight() - nub_height + topAdjustment,
                    left: this.settings.$target.offset().left + leftAdjustment
                }), this.nub_position($nub, this.settings.tip_settings.nub_position, "bottom")) : this.right() ? (this.settings.$next_tip.css({
                    top: this.settings.$target.offset().top + topAdjustment,
                    left: this.settings.$target.outerWidth() + this.settings.$target.offset().left + nub_width + leftAdjustment
                }), this.nub_position($nub, this.settings.tip_settings.nub_position, "left")) : this.left() && (this.settings.$next_tip.css({
                    top: this.settings.$target.offset().top + topAdjustment,
                    left: this.settings.$target.offset().left - this.settings.$next_tip.outerWidth() - nub_width + leftAdjustment
                }), this.nub_position($nub, this.settings.tip_settings.nub_position, "right")), 
                !this.visible(this.corners(this.settings.$next_tip)) && this.settings.attempts < this.settings.tip_settings.tip_location_pattern.length && ($nub.removeClass("bottom").removeClass("top").removeClass("right").removeClass("left"), 
                this.settings.tip_settings.tip_location = this.settings.tip_settings.tip_location_pattern[this.settings.attempts], 
                this.settings.attempts++, this.pos_default());
            }
            toggle && (this.settings.$next_tip.hide(), this.settings.$next_tip.css("visibility", "visible"));
        },
        pos_phone: function(init) {
            var tip_height = this.settings.$next_tip.outerHeight(), target_height = (this.settings.$next_tip.offset(), 
            this.settings.$target.outerHeight()), $nub = $(".joyride-nub", this.settings.$next_tip), nub_height = Math.ceil($nub.outerHeight() / 2), toggle = init || !1;
            $nub.removeClass("bottom").removeClass("top").removeClass("right").removeClass("left"), 
            toggle && (this.settings.$next_tip.css("visibility", "hidden"), this.settings.$next_tip.show()), 
            /body/i.test(this.settings.$target.selector) ? this.settings.$li.length && this.pos_modal($nub) : this.top() ? (this.settings.$next_tip.offset({
                top: this.settings.$target.offset().top - tip_height - nub_height
            }), $nub.addClass("bottom")) : (this.settings.$next_tip.offset({
                top: this.settings.$target.offset().top + target_height + nub_height
            }), $nub.addClass("top")), toggle && (this.settings.$next_tip.hide(), this.settings.$next_tip.css("visibility", "visible"));
        },
        pos_modal: function($nub) {
            this.center(), $nub.hide(), this.show_modal();
        },
        show_modal: function() {
            if (!this.settings.$next_tip.data("closed")) {
                var joyridemodalbg = $(".joyride-modal-bg");
                joyridemodalbg.length < 1 && $("body").append(this.settings.template.modal).show(), 
                /pop/i.test(this.settings.tip_animation) ? joyridemodalbg.show() : joyridemodalbg.fadeIn(this.settings.tip_animation_fade_speed);
            }
        },
        expose: function() {
            var expose, exposeCover, el, origCSS, origClasses, randId = "expose-" + this.random_str(6);
            if (arguments.length > 0 && arguments[0] instanceof $) el = arguments[0]; else {
                if (!this.settings.$target || /body/i.test(this.settings.$target.selector)) return !1;
                el = this.settings.$target;
            }
            return el.length < 1 ? (window.console && console.error("element not valid", el), 
            !1) : (expose = $(this.settings.template.expose), this.settings.$body.append(expose), 
            expose.css({
                top: el.offset().top,
                left: el.offset().left,
                width: el.outerWidth(!0),
                height: el.outerHeight(!0)
            }), exposeCover = $(this.settings.template.expose_cover), origCSS = {
                zIndex: el.css("z-index"),
                position: el.css("position")
            }, origClasses = null == el.attr("class") ? "" : el.attr("class"), el.css("z-index", parseInt(expose.css("z-index")) + 1), 
            "static" == origCSS.position && el.css("position", "relative"), el.data("expose-css", origCSS), 
            el.data("orig-class", origClasses), el.attr("class", origClasses + " " + this.settings.expose_add_class), 
            exposeCover.css({
                top: el.offset().top,
                left: el.offset().left,
                width: el.outerWidth(!0),
                height: el.outerHeight(!0)
            }), this.settings.modal && this.show_modal(), this.settings.$body.append(exposeCover), 
            expose.addClass(randId), exposeCover.addClass(randId), el.data("expose", randId), 
            this.settings.post_expose_callback(this.settings.$li.index(), this.settings.$next_tip, el), 
            void this.add_exposed(el));
        },
        un_expose: function() {
            var exposeId, el, expose, origCSS, origClasses, clearAll = !1;
            if (arguments.length > 0 && arguments[0] instanceof $) el = arguments[0]; else {
                if (!this.settings.$target || /body/i.test(this.settings.$target.selector)) return !1;
                el = this.settings.$target;
            }
            return el.length < 1 ? (window.console && console.error("element not valid", el), 
            !1) : (exposeId = el.data("expose"), expose = $("." + exposeId), arguments.length > 1 && (clearAll = arguments[1]), 
            clearAll === !0 ? $(".joyride-expose-wrapper,.joyride-expose-cover").remove() : expose.remove(), 
            origCSS = el.data("expose-css"), "auto" == origCSS.zIndex ? el.css("z-index", "") : el.css("z-index", origCSS.zIndex), 
            origCSS.position != el.css("position") && ("static" == origCSS.position ? el.css("position", "") : el.css("position", origCSS.position)), 
            origClasses = el.data("orig-class"), el.attr("class", origClasses), el.removeData("orig-classes"), 
            el.removeData("expose"), el.removeData("expose-z-index"), void this.remove_exposed(el));
        },
        add_exposed: function(el) {
            this.settings.exposed = this.settings.exposed || [], el instanceof $ || "object" == typeof el ? this.settings.exposed.push(el[0]) : "string" == typeof el && this.settings.exposed.push(el);
        },
        remove_exposed: function(el) {
            var search, i;
            for (el instanceof $ ? search = el[0] : "string" == typeof el && (search = el), 
            this.settings.exposed = this.settings.exposed || [], i = this.settings.exposed.length; i--; ) if (this.settings.exposed[i] == search) return void this.settings.exposed.splice(i, 1);
        },
        center: function() {
            var $w = $(window);
            return this.settings.$next_tip.css({
                top: ($w.height() - this.settings.$next_tip.outerHeight()) / 2 + $w.scrollTop(),
                left: ($w.width() - this.settings.$next_tip.outerWidth()) / 2 + $w.scrollLeft()
            }), !0;
        },
        bottom: function() {
            return /bottom/i.test(this.settings.tip_settings.tip_location);
        },
        top: function() {
            return /top/i.test(this.settings.tip_settings.tip_location);
        },
        right: function() {
            return /right/i.test(this.settings.tip_settings.tip_location);
        },
        left: function() {
            return /left/i.test(this.settings.tip_settings.tip_location);
        },
        corners: function(el) {
            var w = $(window), window_half = w.height() / 2, tipOffset = Math.ceil(this.settings.$target.offset().top - window_half + this.settings.$next_tip.outerHeight()), right = w.width() + w.scrollLeft(), offsetBottom = w.height() + tipOffset, bottom = w.height() + w.scrollTop(), top = w.scrollTop();
            return top > tipOffset && (top = 0 > tipOffset ? 0 : tipOffset), offsetBottom > bottom && (bottom = offsetBottom), 
            [ el.offset().top < top, right < el.offset().left + el.outerWidth(), bottom < el.offset().top + el.outerHeight(), w.scrollLeft() > el.offset().left ];
        },
        visible: function(hidden_corners) {
            for (var i = hidden_corners.length; i--; ) if (hidden_corners[i]) return !1;
            return !0;
        },
        nub_position: function(nub, pos, def) {
            nub.addClass("auto" === pos ? def : pos);
        },
        startTimer: function() {
            this.settings.$li.length ? this.settings.automate = setTimeout(function() {
                this.hide(), this.show(), this.startTimer();
            }.bind(this), this.settings.timer) : clearTimeout(this.settings.automate);
        },
        end: function(abort) {
            this.settings.cookie_monster && $.cookie(this.settings.cookie_name, "ridden", {
                expires: this.settings.cookie_expires,
                domain: this.settings.cookie_domain
            }), this.settings.timer > 0 && clearTimeout(this.settings.automate), this.settings.modal && this.settings.expose && this.un_expose(), 
            $(this.scope).off("keyup.joyride"), this.settings.$next_tip.data("closed", !0), 
            this.settings.riding = !1, $(".joyride-modal-bg").hide(), this.settings.$current_tip.hide(), 
            ("undefined" == typeof abort || abort === !1) && (this.settings.post_step_callback(this.settings.$li.index(), this.settings.$current_tip), 
            this.settings.post_ride_callback(this.settings.$li.index(), this.settings.$current_tip)), 
            $(".joyride-tip-guide").remove();
        },
        off: function() {
            $(this.scope).off(".joyride"), $(window).off(".joyride"), $(".joyride-close-tip, .joyride-next-tip, .joyride-modal-bg").off(".joyride"), 
            $(".joyride-tip-guide, .joyride-modal-bg").remove(), clearTimeout(this.settings.automate), 
            this.settings = {};
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs["magellan-expedition"] = {
        name: "magellan-expedition",
        version: "5.4.7",
        settings: {
            active_class: "active",
            threshold: 0,
            destination_threshold: 20,
            throttle_delay: 30,
            fixed_top: 0
        },
        init: function(scope, method, options) {
            Foundation.inherit(this, "throttle"), this.bindings(method, options);
        },
        events: function() {
            var self = this, S = self.S, settings = self.settings;
            self.set_expedition_position(), S(self.scope).off(".magellan").on("click.fndtn.magellan", "[" + self.add_namespace("data-magellan-arrival") + '] a[href^="#"]', function(e) {
                e.preventDefault();
                var expedition = $(this).closest("[" + self.attr_name() + "]"), settings = expedition.data("magellan-expedition-init"), hash = this.hash.split("#").join(""), target = $("a[name='" + hash + "']");
                0 === target.length && (target = $("#" + hash));
                var scroll_top = target.offset().top - settings.destination_threshold + 1;
                scroll_top -= expedition.outerHeight(), $("html, body").stop().animate({
                    scrollTop: scroll_top
                }, 700, "swing", function() {
                    history.pushState ? history.pushState(null, null, "#" + hash) : location.hash = "#" + hash;
                });
            }).on("scroll.fndtn.magellan", self.throttle(this.check_for_arrivals.bind(this), settings.throttle_delay)), 
            $(window).on("resize.fndtn.magellan", self.throttle(this.set_expedition_position.bind(this), settings.throttle_delay));
        },
        check_for_arrivals: function() {
            var self = this;
            self.update_arrivals(), self.update_expedition_positions();
        },
        set_expedition_position: function() {
            var self = this;
            $("[" + this.attr_name() + "=fixed]", self.scope).each(function() {
                var top_offset, fixed_top, expedition = $(this), settings = expedition.data("magellan-expedition-init"), styles = expedition.attr("styles");
                expedition.attr("style", ""), top_offset = expedition.offset().top + settings.threshold, 
                fixed_top = parseInt(expedition.data("magellan-fixed-top")), isNaN(fixed_top) || (self.settings.fixed_top = fixed_top), 
                expedition.data(self.data_attr("magellan-top-offset"), top_offset), expedition.attr("style", styles);
            });
        },
        update_expedition_positions: function() {
            var self = this, window_top_offset = $(window).scrollTop();
            $("[" + this.attr_name() + "=fixed]", self.scope).each(function() {
                var expedition = $(this), settings = expedition.data("magellan-expedition-init"), styles = expedition.attr("style"), top_offset = expedition.data("magellan-top-offset");
                if (window_top_offset + self.settings.fixed_top >= top_offset) {
                    var placeholder = expedition.prev("[" + self.add_namespace("data-magellan-expedition-clone") + "]");
                    0 === placeholder.length && (placeholder = expedition.clone(), placeholder.removeAttr(self.attr_name()), 
                    placeholder.attr(self.add_namespace("data-magellan-expedition-clone"), ""), expedition.before(placeholder)), 
                    expedition.css({
                        position: "fixed",
                        top: settings.fixed_top
                    }).addClass("fixed");
                } else expedition.prev("[" + self.add_namespace("data-magellan-expedition-clone") + "]").remove(), 
                expedition.attr("style", styles).css("position", "").css("top", "").removeClass("fixed");
            });
        },
        update_arrivals: function() {
            var self = this, window_top_offset = $(window).scrollTop();
            $("[" + this.attr_name() + "]", self.scope).each(function() {
                var expedition = $(this), settings = expedition.data(self.attr_name(!0) + "-init"), offsets = self.offsets(expedition, window_top_offset), arrivals = expedition.find("[" + self.add_namespace("data-magellan-arrival") + "]"), active_item = !1;
                offsets.each(function(idx, item) {
                    if (item.viewport_offset >= item.top_offset) {
                        var arrivals = expedition.find("[" + self.add_namespace("data-magellan-arrival") + "]");
                        return arrivals.not(item.arrival).removeClass(settings.active_class), item.arrival.addClass(settings.active_class), 
                        active_item = !0, !0;
                    }
                }), active_item || arrivals.removeClass(settings.active_class);
            });
        },
        offsets: function(expedition, window_offset) {
            var self = this, settings = expedition.data(self.attr_name(!0) + "-init"), viewport_offset = window_offset;
            return expedition.find("[" + self.add_namespace("data-magellan-arrival") + "]").map(function() {
                var name = $(this).data(self.data_attr("magellan-arrival")), dest = $("[" + self.add_namespace("data-magellan-destination") + "=" + name + "]");
                if (dest.length > 0) {
                    var top_offset = Math.floor(dest.offset().top - settings.destination_threshold - expedition.outerHeight());
                    return {
                        destination: dest,
                        arrival: $(this),
                        top_offset: top_offset,
                        viewport_offset: viewport_offset
                    };
                }
            }).sort(function(a, b) {
                return a.top_offset < b.top_offset ? -1 : a.top_offset > b.top_offset ? 1 : 0;
            });
        },
        data_attr: function(str) {
            return this.namespace.length > 0 ? this.namespace + "-" + str : str;
        },
        off: function() {
            this.S(this.scope).off(".magellan"), this.S(window).off(".magellan");
        },
        reflow: function() {
            var self = this;
            $("[" + self.add_namespace("data-magellan-expedition-clone") + "]", self.scope).remove();
        }
    };
}(jQuery, window, window.document), function($) {
    "use strict";
    Foundation.libs.offcanvas = {
        name: "offcanvas",
        version: "5.4.7",
        settings: {
            open_method: "move",
            close_on_click: !1
        },
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function() {
            var self = this, S = self.S, move_class = "", right_postfix = "", left_postfix = "";
            "move" === this.settings.open_method ? (move_class = "move-", right_postfix = "right", 
            left_postfix = "left") : "overlap_single" === this.settings.open_method ? (move_class = "offcanvas-overlap-", 
            right_postfix = "right", left_postfix = "left") : "overlap" === this.settings.open_method && (move_class = "offcanvas-overlap"), 
            S(this.scope).off(".offcanvas").on("click.fndtn.offcanvas", ".left-off-canvas-toggle", function(e) {
                self.click_toggle_class(e, move_class + right_postfix), "overlap" !== self.settings.open_method && S(".left-submenu").removeClass(move_class + right_postfix), 
                $(".left-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".left-off-canvas-menu a", function(e) {
                var settings = self.get_settings(e), parent = S(this).parent();
                !settings.close_on_click || parent.hasClass("has-submenu") || parent.hasClass("back") ? S(this).parent().hasClass("has-submenu") ? (e.preventDefault(), 
                S(this).siblings(".left-submenu").toggleClass(move_class + right_postfix)) : parent.hasClass("back") && (e.preventDefault(), 
                parent.parent().removeClass(move_class + right_postfix)) : (self.hide.call(self, move_class + right_postfix, self.get_wrapper(e)), 
                parent.parent().removeClass(move_class + right_postfix)), $(".left-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".right-off-canvas-toggle", function(e) {
                self.click_toggle_class(e, move_class + left_postfix), "overlap" !== self.settings.open_method && S(".right-submenu").removeClass(move_class + left_postfix), 
                $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".right-off-canvas-menu a", function(e) {
                var settings = self.get_settings(e), parent = S(this).parent();
                !settings.close_on_click || parent.hasClass("has-submenu") || parent.hasClass("back") ? S(this).parent().hasClass("has-submenu") ? (e.preventDefault(), 
                S(this).siblings(".right-submenu").toggleClass(move_class + left_postfix)) : parent.hasClass("back") && (e.preventDefault(), 
                parent.parent().removeClass(move_class + left_postfix)) : (self.hide.call(self, move_class + left_postfix, self.get_wrapper(e)), 
                parent.parent().removeClass(move_class + left_postfix)), $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".exit-off-canvas", function(e) {
                self.click_remove_class(e, move_class + left_postfix), S(".right-submenu").removeClass(move_class + left_postfix), 
                right_postfix && (self.click_remove_class(e, move_class + right_postfix), S(".left-submenu").removeClass(move_class + left_postfix)), 
                $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".exit-off-canvas", function(e) {
                self.click_remove_class(e, move_class + left_postfix), $(".left-off-canvas-toggle").attr("aria-expanded", "false"), 
                right_postfix && (self.click_remove_class(e, move_class + right_postfix), $(".right-off-canvas-toggle").attr("aria-expanded", "false"));
            });
        },
        toggle: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.is("." + class_name) ? this.hide(class_name, $off_canvas) : this.show(class_name, $off_canvas);
        },
        show: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.trigger("open").trigger("open.fndtn.offcanvas"), 
            $off_canvas.addClass(class_name);
        },
        hide: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.trigger("close").trigger("close.fndtn.offcanvas"), 
            $off_canvas.removeClass(class_name);
        },
        click_toggle_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.toggle(class_name, $off_canvas);
        },
        click_remove_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.hide(class_name, $off_canvas);
        },
        get_settings: function(e) {
            var offcanvas = this.S(e.target).closest("[" + this.attr_name() + "]");
            return offcanvas.data(this.attr_name(!0) + "-init") || this.settings;
        },
        get_wrapper: function(e) {
            var $off_canvas = this.S(e ? e.target : this.scope).closest(".off-canvas-wrap");
            return 0 === $off_canvas.length && ($off_canvas = this.S(".off-canvas-wrap")), $off_canvas;
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window, document, undefined) {
    "use strict";
    var noop = function() {}, Orbit = function(el, settings) {
        if (el.hasClass(settings.slides_container_class)) return this;
        var container, number_container, bullets_container, timer_container, animate, timer, self = this, slides_container = el, idx = 0, locked = !1;
        self.slides = function() {
            return slides_container.children(settings.slide_selector);
        }, self.slides().first().addClass(settings.active_slide_class), self.update_slide_number = function(index) {
            settings.slide_number && (number_container.find("span:first").text(parseInt(index) + 1), 
            number_container.find("span:last").text(self.slides().length)), settings.bullets && (bullets_container.children().removeClass(settings.bullets_active_class), 
            $(bullets_container.children().get(index)).addClass(settings.bullets_active_class));
        }, self.update_active_link = function(index) {
            var link = $('[data-orbit-link="' + self.slides().eq(index).attr("data-orbit-slide") + '"]');
            link.siblings().removeClass(settings.bullets_active_class), link.addClass(settings.bullets_active_class);
        }, self.build_markup = function() {
            slides_container.wrap('<div class="' + settings.container_class + '"></div>'), container = slides_container.parent(), 
            slides_container.addClass(settings.slides_container_class), settings.stack_on_small && container.addClass(settings.stack_on_small_class), 
            settings.navigation_arrows && (container.append($('<a href="#"><span></span></a>').addClass(settings.prev_class)), 
            container.append($('<a href="#"><span></span></a>').addClass(settings.next_class))), 
            settings.timer && (timer_container = $("<div>").addClass(settings.timer_container_class), 
            timer_container.append("<span>"), timer_container.append($("<div>").addClass(settings.timer_progress_class)), 
            timer_container.addClass(settings.timer_paused_class), container.append(timer_container)), 
            settings.slide_number && (number_container = $("<div>").addClass(settings.slide_number_class), 
            number_container.append("<span></span> " + settings.slide_number_text + " <span></span>"), 
            container.append(number_container)), settings.bullets && (bullets_container = $("<ol>").addClass(settings.bullets_container_class), 
            container.append(bullets_container), bullets_container.wrap('<div class="orbit-bullets-container"></div>'), 
            self.slides().each(function(idx) {
                var bullet = $("<li>").attr("data-orbit-slide", idx).on("click", self.link_bullet);
                bullets_container.append(bullet);
            }));
        }, self._goto = function(next_idx, start_timer) {
            if (next_idx === idx) return !1;
            "object" == typeof timer && timer.restart();
            var slides = self.slides(), dir = "next";
            if (locked = !0, idx > next_idx && (dir = "prev"), next_idx >= slides.length) {
                if (!settings.circular) return !1;
                next_idx = 0;
            } else if (0 > next_idx) {
                if (!settings.circular) return !1;
                next_idx = slides.length - 1;
            }
            var current = $(slides.get(idx)), next = $(slides.get(next_idx));
            current.css("zIndex", 2), current.removeClass(settings.active_slide_class), next.css("zIndex", 4).addClass(settings.active_slide_class), 
            slides_container.trigger("before-slide-change.fndtn.orbit"), settings.before_slide_change(), 
            self.update_active_link(next_idx);
            var callback = function() {
                var unlock = function() {
                    idx = next_idx, locked = !1, start_timer === !0 && (timer = self.create_timer(), 
                    timer.start()), self.update_slide_number(idx), slides_container.trigger("after-slide-change.fndtn.orbit", [ {
                        slide_number: idx,
                        total_slides: slides.length
                    } ]), settings.after_slide_change(idx, slides.length);
                };
                slides_container.height() != next.height() && settings.variable_height ? slides_container.animate({
                    height: next.height()
                }, 250, "linear", unlock) : unlock();
            };
            if (1 === slides.length) return callback(), !1;
            var start_animation = function() {
                "next" === dir && animate.next(current, next, callback), "prev" === dir && animate.prev(current, next, callback);
            };
            next.height() > slides_container.height() && settings.variable_height ? slides_container.animate({
                height: next.height()
            }, 250, "linear", start_animation) : start_animation();
        }, self.next = function(e) {
            e.stopImmediatePropagation(), e.preventDefault(), self._goto(idx + 1);
        }, self.prev = function(e) {
            e.stopImmediatePropagation(), e.preventDefault(), self._goto(idx - 1);
        }, self.link_custom = function(e) {
            e.preventDefault();
            var link = $(this).attr("data-orbit-link");
            if ("string" == typeof link && "" != (link = $.trim(link))) {
                var slide = container.find("[data-orbit-slide=" + link + "]");
                -1 != slide.index() && self._goto(slide.index());
            }
        }, self.link_bullet = function() {
            var index = $(this).attr("data-orbit-slide");
            if ("string" == typeof index && "" != (index = $.trim(index))) if (isNaN(parseInt(index))) {
                var slide = container.find("[data-orbit-slide=" + index + "]");
                -1 != slide.index() && self._goto(slide.index() + 1);
            } else self._goto(parseInt(index));
        }, self.timer_callback = function() {
            self._goto(idx + 1, !0);
        }, self.compute_dimensions = function() {
            var current = $(self.slides().get(idx)), h = current.height();
            settings.variable_height || self.slides().each(function() {
                $(this).height() > h && (h = $(this).height());
            }), slides_container.height(h);
        }, self.create_timer = function() {
            var t = new Timer(container.find("." + settings.timer_container_class), settings, self.timer_callback);
            return t;
        }, self.stop_timer = function() {
            "object" == typeof timer && timer.stop();
        }, self.toggle_timer = function() {
            var t = container.find("." + settings.timer_container_class);
            t.hasClass(settings.timer_paused_class) ? ("undefined" == typeof timer && (timer = self.create_timer()), 
            timer.start()) : "object" == typeof timer && timer.stop();
        }, self.init = function() {
            self.build_markup(), settings.timer && (timer = self.create_timer(), Foundation.utils.image_loaded(this.slides().children("img"), timer.start)), 
            animate = new FadeAnimation(settings, slides_container), "slide" === settings.animation && (animate = new SlideAnimation(settings, slides_container)), 
            container.on("click", "." + settings.next_class, self.next), container.on("click", "." + settings.prev_class, self.prev), 
            settings.next_on_click && container.on("click", "." + settings.slides_container_class + " [data-orbit-slide]", self.link_bullet), 
            container.on("click", self.toggle_timer), settings.swipe && container.on("touchstart.fndtn.orbit", function(e) {
                e.touches || (e = e.originalEvent);
                var data = {
                    start_page_x: e.touches[0].pageX,
                    start_page_y: e.touches[0].pageY,
                    start_time: new Date().getTime(),
                    delta_x: 0,
                    is_scrolling: undefined
                };
                container.data("swipe-transition", data), e.stopPropagation();
            }).on("touchmove.fndtn.orbit", function(e) {
                if (e.touches || (e = e.originalEvent), !(e.touches.length > 1 || e.scale && 1 !== e.scale)) {
                    var data = container.data("swipe-transition");
                    if ("undefined" == typeof data && (data = {}), data.delta_x = e.touches[0].pageX - data.start_page_x, 
                    "undefined" == typeof data.is_scrolling && (data.is_scrolling = !!(data.is_scrolling || Math.abs(data.delta_x) < Math.abs(e.touches[0].pageY - data.start_page_y))), 
                    !data.is_scrolling && !data.active) {
                        e.preventDefault();
                        var direction = data.delta_x < 0 ? idx + 1 : idx - 1;
                        data.active = !0, self._goto(direction);
                    }
                }
            }).on("touchend.fndtn.orbit", function(e) {
                container.data("swipe-transition", {}), e.stopPropagation();
            }), container.on("mouseenter.fndtn.orbit", function() {
                settings.timer && settings.pause_on_hover && self.stop_timer();
            }).on("mouseleave.fndtn.orbit", function() {
                settings.timer && settings.resume_on_mouseout && timer.start();
            }), $(document).on("click", "[data-orbit-link]", self.link_custom), $(window).on("load resize", self.compute_dimensions), 
            Foundation.utils.image_loaded(this.slides().children("img"), self.compute_dimensions), 
            Foundation.utils.image_loaded(this.slides().children("img"), function() {
                container.prev("." + settings.preloader_class).css("display", "none"), self.update_slide_number(0), 
                self.update_active_link(0), slides_container.trigger("ready.fndtn.orbit");
            });
        }, self.init();
    }, Timer = function(el, settings, callback) {
        var start, timeout, self = this, duration = settings.timer_speed, progress = el.find("." + settings.timer_progress_class), left = -1;
        this.update_progress = function(w) {
            var new_progress = progress.clone();
            new_progress.attr("style", ""), new_progress.css("width", w + "%"), progress.replaceWith(new_progress), 
            progress = new_progress;
        }, this.restart = function() {
            clearTimeout(timeout), el.addClass(settings.timer_paused_class), left = -1, self.update_progress(0);
        }, this.start = function() {
            return el.hasClass(settings.timer_paused_class) ? (left = -1 === left ? duration : left, 
            el.removeClass(settings.timer_paused_class), start = new Date().getTime(), progress.animate({
                width: "100%"
            }, left, "linear"), timeout = setTimeout(function() {
                self.restart(), callback();
            }, left), void el.trigger("timer-started.fndtn.orbit")) : !0;
        }, this.stop = function() {
            if (el.hasClass(settings.timer_paused_class)) return !0;
            clearTimeout(timeout), el.addClass(settings.timer_paused_class);
            var end = new Date().getTime();
            left -= end - start;
            var w = 100 - left / duration * 100;
            self.update_progress(w), el.trigger("timer-stopped.fndtn.orbit");
        };
    }, SlideAnimation = function(settings) {
        var duration = settings.animation_speed, is_rtl = 1 === $("html[dir=rtl]").length, margin = is_rtl ? "marginRight" : "marginLeft", animMargin = {};
        animMargin[margin] = "0%", this.next = function(current, next, callback) {
            current.animate({
                marginLeft: "-100%"
            }, duration), next.animate(animMargin, duration, function() {
                current.css(margin, "100%"), callback();
            });
        }, this.prev = function(current, prev, callback) {
            current.animate({
                marginLeft: "100%"
            }, duration), prev.css(margin, "-100%"), prev.animate(animMargin, duration, function() {
                current.css(margin, "100%"), callback();
            });
        };
    }, FadeAnimation = function(settings) {
        {
            var duration = settings.animation_speed;
            1 === $("html[dir=rtl]").length;
        }
        this.next = function(current, next, callback) {
            next.css({
                margin: "0%",
                opacity: "0.01"
            }), next.animate({
                opacity: "1"
            }, duration, "linear", function() {
                current.css("margin", "100%"), callback();
            });
        }, this.prev = function(current, prev, callback) {
            prev.css({
                margin: "0%",
                opacity: "0.01"
            }), prev.animate({
                opacity: "1"
            }, duration, "linear", function() {
                current.css("margin", "100%"), callback();
            });
        };
    };
    Foundation.libs = Foundation.libs || {}, Foundation.libs.orbit = {
        name: "orbit",
        version: "5.4.7",
        settings: {
            animation: "slide",
            timer_speed: 1e4,
            pause_on_hover: !0,
            resume_on_mouseout: !1,
            next_on_click: !0,
            animation_speed: 500,
            stack_on_small: !1,
            navigation_arrows: !0,
            slide_number: !0,
            slide_number_text: "of",
            container_class: "orbit-container",
            stack_on_small_class: "orbit-stack-on-small",
            next_class: "orbit-next",
            prev_class: "orbit-prev",
            timer_container_class: "orbit-timer",
            timer_paused_class: "paused",
            timer_progress_class: "orbit-progress",
            slides_container_class: "orbit-slides-container",
            preloader_class: "preloader",
            slide_selector: "*",
            bullets_container_class: "orbit-bullets",
            bullets_active_class: "active",
            slide_number_class: "orbit-slide-number",
            caption_class: "orbit-caption",
            active_slide_class: "active",
            orbit_transition_class: "orbit-transitioning",
            bullets: !0,
            circular: !0,
            timer: !0,
            variable_height: !1,
            swipe: !0,
            before_slide_change: noop,
            after_slide_change: noop
        },
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function(instance) {
            var orbit_instance = new Orbit(this.S(instance), this.S(instance).data("orbit-init"));
            this.S(instance).data(this.name + "-instance", orbit_instance);
        },
        reflow: function() {
            var self = this;
            if (self.S(self.scope).is("[data-orbit]")) {
                var $el = self.S(self.scope), instance = $el.data(self.name + "-instance");
                instance.compute_dimensions();
            } else self.S("[data-orbit]", self.scope).each(function(idx, el) {
                var $el = self.S(el), instance = (self.data_options($el), $el.data(self.name + "-instance"));
                instance.compute_dimensions();
            });
        }
    };
}(jQuery, window, window.document), function($, window, document, undefined) {
    "use strict";
    function getAnimationData(str) {
        var fade = /fade/i.test(str), pop = /pop/i.test(str);
        return {
            animate: fade || pop,
            pop: pop,
            fade: fade
        };
    }
    Foundation.libs.reveal = {
        name: "reveal",
        version: "5.4.7",
        locked: !1,
        settings: {
            animation: "fadeAndPop",
            animation_speed: 250,
            close_on_background_click: !0,
            close_on_esc: !0,
            dismiss_modal_class: "close-reveal-modal",
            bg_class: "reveal-modal-bg",
            root_element: "body",
            open: function() {},
            opened: function() {},
            close: function() {},
            closed: function() {},
            bg: $(".reveal-modal-bg"),
            css: {
                open: {
                    opacity: 0,
                    visibility: "visible",
                    display: "block"
                },
                close: {
                    opacity: 1,
                    visibility: "hidden",
                    display: "none"
                }
            }
        },
        init: function(scope, method, options) {
            $.extend(!0, this.settings, method, options), this.bindings(method, options);
        },
        events: function() {
            var self = this, S = self.S;
            return S(this.scope).off(".reveal").on("click.fndtn.reveal", "[" + this.add_namespace("data-reveal-id") + "]:not([disabled])", function(e) {
                if (e.preventDefault(), !self.locked) {
                    var element = S(this), ajax = element.data(self.data_attr("reveal-ajax"));
                    if (self.locked = !0, "undefined" == typeof ajax) self.open.call(self, element); else {
                        var url = ajax === !0 ? element.attr("href") : ajax;
                        self.open.call(self, element, {
                            url: url
                        });
                    }
                }
            }), S(document).on("click.fndtn.reveal", this.close_targets(), function(e) {
                if (e.preventDefault(), !self.locked) {
                    var settings = S("[" + self.attr_name() + "].open").data(self.attr_name(!0) + "-init") || self.settings, bg_clicked = S(e.target)[0] === S("." + settings.bg_class)[0];
                    if (bg_clicked) {
                        if (!settings.close_on_background_click) return;
                        e.stopPropagation();
                    }
                    self.locked = !0, self.close.call(self, bg_clicked ? S("[" + self.attr_name() + "].open") : S(this).closest("[" + self.attr_name() + "]"));
                }
            }), S("[" + self.attr_name() + "]", this.scope).length > 0 ? S(this.scope).on("open.fndtn.reveal", this.settings.open).on("opened.fndtn.reveal", this.settings.opened).on("opened.fndtn.reveal", this.open_video).on("close.fndtn.reveal", this.settings.close).on("closed.fndtn.reveal", this.settings.closed).on("closed.fndtn.reveal", this.close_video) : S(this.scope).on("open.fndtn.reveal", "[" + self.attr_name() + "]", this.settings.open).on("opened.fndtn.reveal", "[" + self.attr_name() + "]", this.settings.opened).on("opened.fndtn.reveal", "[" + self.attr_name() + "]", this.open_video).on("close.fndtn.reveal", "[" + self.attr_name() + "]", this.settings.close).on("closed.fndtn.reveal", "[" + self.attr_name() + "]", this.settings.closed).on("closed.fndtn.reveal", "[" + self.attr_name() + "]", this.close_video), 
            !0;
        },
        key_up_on: function() {
            var self = this;
            return self.S("body").off("keyup.fndtn.reveal").on("keyup.fndtn.reveal", function(event) {
                var open_modal = self.S("[" + self.attr_name() + "].open"), settings = open_modal.data(self.attr_name(!0) + "-init") || self.settings;
                settings && 27 === event.which && settings.close_on_esc && !self.locked && self.close.call(self, open_modal);
            }), !0;
        },
        key_up_off: function() {
            return this.S("body").off("keyup.fndtn.reveal"), !0;
        },
        open: function(target, ajax_settings) {
            var modal, self = this;
            target ? "undefined" != typeof target.selector ? modal = self.S("#" + target.data(self.data_attr("reveal-id"))).first() : (modal = self.S(this.scope), 
            ajax_settings = target) : modal = self.S(this.scope);
            var settings = modal.data(self.attr_name(!0) + "-init");
            if (settings = settings || this.settings, modal.hasClass("open") && target.attr("data-reveal-id") == modal.attr("id")) return self.close(modal);
            if (!modal.hasClass("open")) {
                var open_modal = self.S("[" + self.attr_name() + "].open");
                if ("undefined" == typeof modal.data("css-top") && modal.data("css-top", parseInt(modal.css("top"), 10)).data("offset", this.cache_offset(modal)), 
                this.key_up_on(modal), modal.trigger("open").trigger("open.fndtn.reveal"), open_modal.length < 1 && this.toggle_bg(modal, !0), 
                "string" == typeof ajax_settings && (ajax_settings = {
                    url: ajax_settings
                }), "undefined" != typeof ajax_settings && ajax_settings.url) {
                    var old_success = "undefined" != typeof ajax_settings.success ? ajax_settings.success : null;
                    $.extend(ajax_settings, {
                        success: function(data, textStatus, jqXHR) {
                            $.isFunction(old_success) && old_success(data, textStatus, jqXHR), modal.html(data), 
                            self.S(modal).foundation("section", "reflow"), self.S(modal).children().foundation(), 
                            open_modal.length > 0 && self.hide(open_modal, settings.css.close), self.show(modal, settings.css.open);
                        }
                    }), $.ajax(ajax_settings);
                } else open_modal.length > 0 && this.hide(open_modal, settings.css.close), this.show(modal, settings.css.open);
            }
            self.S(window).trigger("resize");
        },
        close: function(modal) {
            var modal = modal && modal.length ? modal : this.S(this.scope), open_modals = this.S("[" + this.attr_name() + "].open"), settings = modal.data(this.attr_name(!0) + "-init") || this.settings;
            open_modals.length > 0 && (this.locked = !0, this.key_up_off(modal), modal.trigger("close").trigger("close.fndtn.reveal"), 
            this.toggle_bg(modal, !1), this.hide(open_modals, settings.css.close, settings));
        },
        close_targets: function() {
            var base = "." + this.settings.dismiss_modal_class;
            return this.settings.close_on_background_click ? base + ", ." + this.settings.bg_class : base;
        },
        toggle_bg: function(modal, state) {
            0 === this.S("." + this.settings.bg_class).length && (this.settings.bg = $("<div />", {
                "class": this.settings.bg_class
            }).appendTo("body").hide());
            var visible = this.settings.bg.filter(":visible").length > 0;
            state != visible && ((state == undefined ? visible : !state) ? this.hide(this.settings.bg) : this.show(this.settings.bg));
        },
        show: function(el, css) {
            if (css) {
                var settings = el.data(this.attr_name(!0) + "-init") || this.settings, root_element = settings.root_element;
                if (0 === el.parent(root_element).length) {
                    var placeholder = el.wrap('<div style="display: none;" />').parent();
                    el.on("closed.fndtn.reveal.wrapped", function() {
                        el.detach().appendTo(placeholder), el.unwrap().unbind("closed.fndtn.reveal.wrapped");
                    }), el.detach().appendTo(root_element);
                }
                var animData = getAnimationData(settings.animation);
                if (animData.animate || (this.locked = !1), animData.pop) {
                    css.top = $(window).scrollTop() - el.data("offset") + "px";
                    var end_css = {
                        top: $(window).scrollTop() + el.data("css-top") + "px",
                        opacity: 1
                    };
                    return setTimeout(function() {
                        return el.css(css).animate(end_css, settings.animation_speed, "linear", function() {
                            this.locked = !1, el.trigger("opened").trigger("opened.fndtn.reveal");
                        }.bind(this)).addClass("open");
                    }.bind(this), settings.animation_speed / 2);
                }
                if (animData.fade) {
                    css.top = $(window).scrollTop() + el.data("css-top") + "px";
                    var end_css = {
                        opacity: 1
                    };
                    return setTimeout(function() {
                        return el.css(css).animate(end_css, settings.animation_speed, "linear", function() {
                            this.locked = !1, el.trigger("opened").trigger("opened.fndtn.reveal");
                        }.bind(this)).addClass("open");
                    }.bind(this), settings.animation_speed / 2);
                }
                return el.css(css).show().css({
                    opacity: 1
                }).addClass("open").trigger("opened").trigger("opened.fndtn.reveal");
            }
            var settings = this.settings;
            return getAnimationData(settings.animation).fade ? el.fadeIn(settings.animation_speed / 2) : (this.locked = !1, 
            el.show());
        },
        hide: function(el, css) {
            if (css) {
                var settings = el.data(this.attr_name(!0) + "-init");
                settings = settings || this.settings;
                var animData = getAnimationData(settings.animation);
                if (animData.animate || (this.locked = !1), animData.pop) {
                    var end_css = {
                        top: -$(window).scrollTop() - el.data("offset") + "px",
                        opacity: 0
                    };
                    return setTimeout(function() {
                        return el.animate(end_css, settings.animation_speed, "linear", function() {
                            this.locked = !1, el.css(css).trigger("closed").trigger("closed.fndtn.reveal");
                        }.bind(this)).removeClass("open");
                    }.bind(this), settings.animation_speed / 2);
                }
                if (animData.fade) {
                    var end_css = {
                        opacity: 0
                    };
                    return setTimeout(function() {
                        return el.animate(end_css, settings.animation_speed, "linear", function() {
                            this.locked = !1, el.css(css).trigger("closed").trigger("closed.fndtn.reveal");
                        }.bind(this)).removeClass("open");
                    }.bind(this), settings.animation_speed / 2);
                }
                return el.hide().css(css).removeClass("open").trigger("closed").trigger("closed.fndtn.reveal");
            }
            var settings = this.settings;
            return getAnimationData(settings.animation).fade ? el.fadeOut(settings.animation_speed / 2) : el.hide();
        },
        close_video: function(e) {
            var video = $(".flex-video", e.target), iframe = $("iframe", video);
            iframe.length > 0 && (iframe.attr("data-src", iframe[0].src), iframe.attr("src", iframe.attr("src")), 
            video.hide());
        },
        open_video: function(e) {
            var video = $(".flex-video", e.target), iframe = video.find("iframe");
            if (iframe.length > 0) {
                var data_src = iframe.attr("data-src");
                if ("string" == typeof data_src) iframe[0].src = iframe.attr("data-src"); else {
                    var src = iframe[0].src;
                    iframe[0].src = undefined, iframe[0].src = src;
                }
                video.show();
            }
        },
        data_attr: function(str) {
            return this.namespace.length > 0 ? this.namespace + "-" + str : str;
        },
        cache_offset: function(modal) {
            var offset = modal.show().height() + parseInt(modal.css("top"), 10);
            return modal.hide(), offset;
        },
        off: function() {
            $(this.scope).off(".fndtn.reveal");
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs.slider = {
        name: "slider",
        version: "5.4.7",
        settings: {
            start: 0,
            end: 100,
            step: 1,
            initial: null,
            display_selector: "",
            vertical: !1,
            on_change: function() {}
        },
        cache: {},
        init: function(scope, method, options) {
            Foundation.inherit(this, "throttle"), this.bindings(method, options), this.reflow();
        },
        events: function() {
            var self = this;
            $(this.scope).off(".slider").on("mousedown.fndtn.slider touchstart.fndtn.slider pointerdown.fndtn.slider", "[" + self.attr_name() + "]:not(.disabled, [disabled]) .range-slider-handle", function(e) {
                self.cache.active || (e.preventDefault(), self.set_active_slider($(e.target)));
            }).on("mousemove.fndtn.slider touchmove.fndtn.slider pointermove.fndtn.slider", function(e) {
                if (self.cache.active) if (e.preventDefault(), $.data(self.cache.active[0], "settings").vertical) {
                    var scroll_offset = 0;
                    e.pageY || (scroll_offset = window.scrollY), self.calculate_position(self.cache.active, (e.pageY || e.originalEvent.clientY || e.originalEvent.touches[0].clientY || e.currentPoint.y) + scroll_offset);
                } else self.calculate_position(self.cache.active, e.pageX || e.originalEvent.clientX || e.originalEvent.touches[0].clientX || e.currentPoint.x);
            }).on("mouseup.fndtn.slider touchend.fndtn.slider pointerup.fndtn.slider", function() {
                self.remove_active_slider();
            }).on("change.fndtn.slider", function() {
                self.settings.on_change();
            }), self.S(window).on("resize.fndtn.slider", self.throttle(function() {
                self.reflow();
            }, 300));
        },
        set_active_slider: function($handle) {
            this.cache.active = $handle;
        },
        remove_active_slider: function() {
            this.cache.active = null;
        },
        calculate_position: function($handle, cursor_x) {
            var self = this, settings = $.data($handle[0], "settings"), bar_l = ($.data($handle[0], "handle_l"), 
            $.data($handle[0], "handle_o"), $.data($handle[0], "bar_l")), bar_o = $.data($handle[0], "bar_o");
            requestAnimationFrame(function() {
                var pct;
                pct = Foundation.rtl && !settings.vertical ? self.limit_to((bar_o + bar_l - cursor_x) / bar_l, 0, 1) : self.limit_to((cursor_x - bar_o) / bar_l, 0, 1), 
                pct = settings.vertical ? 1 - pct : pct;
                var norm = self.normalized_value(pct, settings.start, settings.end, settings.step);
                self.set_ui($handle, norm);
            });
        },
        set_ui: function($handle, value) {
            var settings = $.data($handle[0], "settings"), handle_l = $.data($handle[0], "handle_l"), bar_l = $.data($handle[0], "bar_l"), norm_pct = this.normalized_percentage(value, settings.start, settings.end), handle_offset = norm_pct * (bar_l - handle_l) - 1, progress_bar_length = 100 * norm_pct;
            Foundation.rtl && !settings.vertical && (handle_offset = -handle_offset), handle_offset = settings.vertical ? -handle_offset + bar_l - handle_l + 1 : handle_offset, 
            this.set_translate($handle, handle_offset, settings.vertical), settings.vertical ? $handle.siblings(".range-slider-active-segment").css("height", progress_bar_length + "%") : $handle.siblings(".range-slider-active-segment").css("width", progress_bar_length + "%"), 
            $handle.parent().attr(this.attr_name(), value).trigger("change").trigger("change.fndtn.slider"), 
            $handle.parent().children("input[type=hidden]").val(value), $handle[0].hasAttribute("aria-valuemin") || $handle.attr({
                "aria-valuemin": settings.start,
                "aria-valuemax": settings.end
            }), $handle.attr("aria-valuenow", value), "" != settings.display_selector && $(settings.display_selector).each(function() {
                this.hasOwnProperty("value") ? $(this).val(value) : $(this).text(value);
            });
        },
        normalized_percentage: function(val, start, end) {
            return Math.min(1, (val - start) / (end - start));
        },
        normalized_value: function(val, start, end, step) {
            var range = end - start, point = val * range, mod = (point - point % step) / step, rem = point % step, round = rem >= .5 * step ? step : 0;
            return mod * step + round + start;
        },
        set_translate: function(ele, offset, vertical) {
            vertical ? $(ele).css("-webkit-transform", "translateY(" + offset + "px)").css("-moz-transform", "translateY(" + offset + "px)").css("-ms-transform", "translateY(" + offset + "px)").css("-o-transform", "translateY(" + offset + "px)").css("transform", "translateY(" + offset + "px)") : $(ele).css("-webkit-transform", "translateX(" + offset + "px)").css("-moz-transform", "translateX(" + offset + "px)").css("-ms-transform", "translateX(" + offset + "px)").css("-o-transform", "translateX(" + offset + "px)").css("transform", "translateX(" + offset + "px)");
        },
        limit_to: function(val, min, max) {
            return Math.min(Math.max(val, min), max);
        },
        initialize_settings: function(handle) {
            var settings = $.extend({}, this.settings, this.data_options($(handle).parent()));
            settings.vertical ? ($.data(handle, "bar_o", $(handle).parent().offset().top), $.data(handle, "bar_l", $(handle).parent().outerHeight()), 
            $.data(handle, "handle_o", $(handle).offset().top), $.data(handle, "handle_l", $(handle).outerHeight())) : ($.data(handle, "bar_o", $(handle).parent().offset().left), 
            $.data(handle, "bar_l", $(handle).parent().outerWidth()), $.data(handle, "handle_o", $(handle).offset().left), 
            $.data(handle, "handle_l", $(handle).outerWidth())), $.data(handle, "bar", $(handle).parent()), 
            $.data(handle, "settings", settings);
        },
        set_initial_position: function($ele) {
            var settings = $.data($ele.children(".range-slider-handle")[0], "settings"), initial = settings.initial ? settings.initial : Math.floor(.5 * (settings.end - settings.start) / settings.step) * settings.step + settings.start, $handle = $ele.children(".range-slider-handle");
            this.set_ui($handle, initial);
        },
        set_value: function(value) {
            var self = this;
            $("[" + self.attr_name() + "]", this.scope).each(function() {
                $(this).attr(self.attr_name(), value);
            }), $(this.scope).attr(self.attr_name()) && $(this.scope).attr(self.attr_name(), value), 
            self.reflow();
        },
        reflow: function() {
            var self = this;
            self.S("[" + this.attr_name() + "]").each(function() {
                var handle = $(this).children(".range-slider-handle")[0], val = $(this).attr(self.attr_name());
                self.initialize_settings(handle), val ? self.set_ui($(handle), parseFloat(val)) : self.set_initial_position($(this));
            });
        }
    };
}(jQuery, window, window.document), function($, window, document, undefined) {
    "use strict";
    Foundation.libs.tab = {
        name: "tab",
        version: "5.4.7",
        settings: {
            active_class: "active",
            callback: function() {},
            deep_linking: !1,
            scroll_to_content: !0,
            is_hover: !1
        },
        default_tab_hashes: [],
        init: function(scope, method, options) {
            var self = this, S = this.S;
            this.bindings(method, options), this.handle_location_hash_change(), S("[" + this.attr_name() + "] > .active > a", this.scope).each(function() {
                self.default_tab_hashes.push(this.hash);
            });
        },
        events: function() {
            var self = this, S = this.S, usual_tab_behavior = function(e) {
                var settings = S(this).closest("[" + self.attr_name() + "]").data(self.attr_name(!0) + "-init");
                (!settings.is_hover || Modernizr.touch) && (e.preventDefault(), e.stopPropagation(), 
                self.toggle_active_tab(S(this).parent()));
            };
            S(this.scope).off(".tab").on("focus.fndtn.tab", "[" + this.attr_name() + "] > * > a", usual_tab_behavior).on("click.fndtn.tab", "[" + this.attr_name() + "] > * > a", usual_tab_behavior).on("mouseenter.fndtn.tab", "[" + this.attr_name() + "] > * > a", function() {
                var settings = S(this).closest("[" + self.attr_name() + "]").data(self.attr_name(!0) + "-init");
                settings.is_hover && self.toggle_active_tab(S(this).parent());
            }), S(window).on("hashchange.fndtn.tab", function(e) {
                e.preventDefault(), self.handle_location_hash_change();
            });
        },
        handle_location_hash_change: function() {
            var self = this, S = this.S;
            S("[" + this.attr_name() + "]", this.scope).each(function() {
                var settings = S(this).data(self.attr_name(!0) + "-init");
                if (settings.deep_linking) {
                    var hash;
                    if (hash = settings.scroll_to_content ? self.scope.location.hash : self.scope.location.hash.replace("fndtn-", ""), 
                    "" != hash) {
                        var hash_element = S(hash);
                        if (hash_element.hasClass("content") && hash_element.parent().hasClass("tabs-content")) self.toggle_active_tab($("[" + self.attr_name() + "] > * > a[href=" + hash + "]").parent()); else {
                            var hash_tab_container_id = hash_element.closest(".content").attr("id");
                            hash_tab_container_id != undefined && self.toggle_active_tab($("[" + self.attr_name() + "] > * > a[href=#" + hash_tab_container_id + "]").parent(), hash);
                        }
                    } else for (var ind = 0; ind < self.default_tab_hashes.length; ind++) self.toggle_active_tab($("[" + self.attr_name() + "] > * > a[href=" + self.default_tab_hashes[ind] + "]").parent());
                }
            });
        },
        toggle_active_tab: function(tab, location_hash) {
            var S = this.S, tabs = tab.closest("[" + this.attr_name() + "]"), tab_link = tab.find("a"), anchor = tab.children("a").first(), target_hash = "#" + anchor.attr("href").split("#")[1], target = S(target_hash), siblings = tab.siblings(), settings = tabs.data(this.attr_name(!0) + "-init"), interpret_keyup_action = function(e) {
                var $target, $original = $(this), $prev = $(this).parents("li").prev().children('[role="tab"]'), $next = $(this).parents("li").next().children('[role="tab"]');
                switch (e.keyCode) {
                  case 37:
                    $target = $prev;
                    break;

                  case 39:
                    $target = $next;
                    break;

                  default:
                    $target = !1;
                }
                $target.length && ($original.attr({
                    tabindex: "-1",
                    "aria-selected": null
                }), $target.attr({
                    tabindex: "0",
                    "aria-selected": !0
                }).focus()), $('[role="tabpanel"]').attr("aria-hidden", "true"), $("#" + $(document.activeElement).attr("href").substring(1)).attr("aria-hidden", null);
            };
            S(this).data(this.data_attr("tab-content")) && (target_hash = "#" + S(this).data(this.data_attr("tab-content")).split("#")[1], 
            target = S(target_hash)), settings.deep_linking && (settings.scroll_to_content ? (window.location.hash = location_hash || target_hash, 
            location_hash == undefined || location_hash == target_hash ? tab.parent()[0].scrollIntoView() : S(target_hash)[0].scrollIntoView()) : window.location.hash = location_hash != undefined ? "fndtn-" + location_hash.replace("#", "") : "fndtn-" + target_hash.replace("#", "")), 
            tab.addClass(settings.active_class).triggerHandler("opened"), tab_link.attr({
                "aria-selected": "true",
                tabindex: 0
            }), siblings.removeClass(settings.active_class), siblings.find("a").attr({
                "aria-selected": "false",
                tabindex: -1
            }), target.siblings().removeClass(settings.active_class).attr({
                "aria-hidden": "true",
                tabindex: -1
            }), target.addClass(settings.active_class).attr("aria-hidden", "false").removeAttr("tabindex"), 
            settings.callback(tab), target.triggerHandler("toggled", [ tab ]), tabs.triggerHandler("toggled", [ target ]), 
            tab_link.off("keydown").on("keydown", interpret_keyup_action);
        },
        data_attr: function(str) {
            return this.namespace.length > 0 ? this.namespace + "-" + str : str;
        },
        off: function() {},
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window) {
    "use strict";
    Foundation.libs.tooltip = {
        name: "tooltip",
        version: "5.4.7",
        settings: {
            additional_inheritable_classes: [],
            tooltip_class: ".tooltip",
            append_to: "body",
            touch_close_text: "Tap To Close",
            disable_for_touch: !1,
            hover_delay: 200,
            show_on: "all",
            tip_template: function(selector, content) {
                return '<span data-selector="' + selector + '" id="' + selector + '" class="' + Foundation.libs.tooltip.settings.tooltip_class.substring(1) + '" role="tooltip">' + content + '<span class="nub"></span></span>';
            }
        },
        cache: {},
        init: function(scope, method, options) {
            Foundation.inherit(this, "random_str"), this.bindings(method, options);
        },
        should_show: function(target) {
            var settings = $.extend({}, this.settings, this.data_options(target));
            return "all" === settings.show_on ? !0 : this.small() && "small" === settings.show_on ? !0 : this.medium() && "medium" === settings.show_on ? !0 : this.large() && "large" === settings.show_on ? !0 : !1;
        },
        medium: function() {
            return matchMedia(Foundation.media_queries.medium).matches;
        },
        large: function() {
            return matchMedia(Foundation.media_queries.large).matches;
        },
        events: function(instance) {
            var self = this, S = self.S;
            self.create(this.S(instance)), $(this.scope).off(".tooltip").on("mouseenter.fndtn.tooltip mouseleave.fndtn.tooltip touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip", "[" + this.attr_name() + "]", function(e) {
                var $this = S(this), settings = $.extend({}, self.settings, self.data_options($this)), is_touch = !1;
                if (Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type) && S(e.target).is("a")) return !1;
                if (/mouse/i.test(e.type) && self.ie_touch(e)) return !1;
                if ($this.hasClass("open")) Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type) && e.preventDefault(), 
                self.hide($this); else {
                    if (settings.disable_for_touch && Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type)) return;
                    !settings.disable_for_touch && Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type) && (e.preventDefault(), 
                    S(settings.tooltip_class + ".open").hide(), is_touch = !0), /enter|over/i.test(e.type) ? this.timer = setTimeout(function() {
                        self.showTip($this);
                    }.bind(this), self.settings.hover_delay) : "mouseout" === e.type || "mouseleave" === e.type ? (clearTimeout(this.timer), 
                    self.hide($this)) : self.showTip($this);
                }
            }).on("mouseleave.fndtn.tooltip touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip", "[" + this.attr_name() + "].open", function(e) {
                return /mouse/i.test(e.type) && self.ie_touch(e) ? !1 : void (("touch" != $(this).data("tooltip-open-event-type") || "mouseleave" != e.type) && ("mouse" == $(this).data("tooltip-open-event-type") && /MSPointerDown|touchstart/i.test(e.type) ? self.convert_to_touch($(this)) : self.hide($(this))));
            }).on("DOMNodeRemoved DOMAttrModified", "[" + this.attr_name() + "]:not(a)", function() {
                self.hide(S(this));
            });
        },
        ie_touch: function() {
            return !1;
        },
        showTip: function($target) {
            var $tip = this.getTip($target);
            return this.should_show($target, $tip) ? this.show($target) : void 0;
        },
        getTip: function($target) {
            var selector = this.selector($target), settings = $.extend({}, this.settings, this.data_options($target)), tip = null;
            return selector && (tip = this.S('span[data-selector="' + selector + '"]' + settings.tooltip_class)), 
            "object" == typeof tip ? tip : !1;
        },
        selector: function($target) {
            var id = $target.attr("id"), dataSelector = $target.attr(this.attr_name()) || $target.attr("data-selector");
            return (id && id.length < 1 || !id) && "string" != typeof dataSelector && (dataSelector = this.random_str(6), 
            $target.attr("data-selector", dataSelector).attr("aria-describedby", dataSelector)), 
            id && id.length > 0 ? id : dataSelector;
        },
        create: function($target) {
            var self = this, settings = $.extend({}, this.settings, this.data_options($target)), tip_template = this.settings.tip_template;
            "string" == typeof settings.tip_template && window.hasOwnProperty(settings.tip_template) && (tip_template = window[settings.tip_template]);
            var $tip = $(tip_template(this.selector($target), $("<div></div>").html($target.attr("title")).html())), classes = this.inheritable_classes($target);
            $tip.addClass(classes).appendTo(settings.append_to), Modernizr.touch && ($tip.append('<span class="tap-to-close">' + settings.touch_close_text + "</span>"), 
            $tip.on("touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip", function() {
                self.hide($target);
            })), $target.removeAttr("title").attr("title", "");
        },
        reposition: function(target, tip, classes) {
            var width, nub, nubHeight, nubWidth, objPos;
            if (tip.css("visibility", "hidden").show(), width = target.data("width"), nub = tip.children(".nub"), 
            nubHeight = nub.outerHeight(), nubWidth = nub.outerHeight(), tip.css(this.small() ? {
                width: "100%"
            } : {
                width: width ? width : "auto"
            }), objPos = function(obj, top, right, bottom, left) {
                return obj.css({
                    top: top ? top : "auto",
                    bottom: bottom ? bottom : "auto",
                    left: left ? left : "auto",
                    right: right ? right : "auto"
                }).end();
            }, objPos(tip, target.offset().top + target.outerHeight() + 10, "auto", "auto", target.offset().left), 
            this.small()) objPos(tip, target.offset().top + target.outerHeight() + 10, "auto", "auto", 12.5, $(this.scope).width()), 
            tip.addClass("tip-override"), objPos(nub, -nubHeight, "auto", "auto", target.offset().left); else {
                var left = target.offset().left;
                Foundation.rtl && (nub.addClass("rtl"), left = target.offset().left + target.outerWidth() - tip.outerWidth()), 
                objPos(tip, target.offset().top + target.outerHeight() + 10, "auto", "auto", left), 
                tip.removeClass("tip-override"), classes && classes.indexOf("tip-top") > -1 ? (Foundation.rtl && nub.addClass("rtl"), 
                objPos(tip, target.offset().top - tip.outerHeight(), "auto", "auto", left).removeClass("tip-override")) : classes && classes.indexOf("tip-left") > -1 ? (objPos(tip, target.offset().top + target.outerHeight() / 2 - tip.outerHeight() / 2, "auto", "auto", target.offset().left - tip.outerWidth() - nubHeight).removeClass("tip-override"), 
                nub.removeClass("rtl")) : classes && classes.indexOf("tip-right") > -1 && (objPos(tip, target.offset().top + target.outerHeight() / 2 - tip.outerHeight() / 2, "auto", "auto", target.offset().left + target.outerWidth() + nubHeight).removeClass("tip-override"), 
                nub.removeClass("rtl"));
            }
            tip.css("visibility", "visible").hide();
        },
        small: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },
        inheritable_classes: function($target) {
            var settings = $.extend({}, this.settings, this.data_options($target)), inheritables = [ "tip-top", "tip-left", "tip-bottom", "tip-right", "radius", "round" ].concat(settings.additional_inheritable_classes), classes = $target.attr("class"), filtered = classes ? $.map(classes.split(" "), function(el) {
                return -1 !== $.inArray(el, inheritables) ? el : void 0;
            }).join(" ") : "";
            return $.trim(filtered);
        },
        convert_to_touch: function($target) {
            var self = this, $tip = self.getTip($target), settings = $.extend({}, self.settings, self.data_options($target));
            0 === $tip.find(".tap-to-close").length && ($tip.append('<span class="tap-to-close">' + settings.touch_close_text + "</span>"), 
            $tip.on("click.fndtn.tooltip.tapclose touchstart.fndtn.tooltip.tapclose MSPointerDown.fndtn.tooltip.tapclose", function() {
                self.hide($target);
            })), $target.data("tooltip-open-event-type", "touch");
        },
        show: function($target) {
            var $tip = this.getTip($target);
            "touch" == $target.data("tooltip-open-event-type") && this.convert_to_touch($target), 
            this.reposition($target, $tip, $target.attr("class")), $target.addClass("open"), 
            $tip.fadeIn(150);
        },
        hide: function($target) {
            var $tip = this.getTip($target);
            $tip.fadeOut(150, function() {
                $tip.find(".tap-to-close").remove(), $tip.off("click.fndtn.tooltip.tapclose MSPointerDown.fndtn.tapclose"), 
                $target.removeClass("open");
            });
        },
        off: function() {
            var self = this;
            this.S(this.scope).off(".fndtn.tooltip"), this.S(this.settings.tooltip_class).each(function(i) {
                $("[" + self.attr_name() + "]").eq(i).attr("title", $(this).text());
            }).remove();
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($, window, document) {
    "use strict";
    Foundation.libs.topbar = {
        name: "topbar",
        version: "5.4.7",
        settings: {
            index: 0,
            sticky_class: "sticky",
            custom_back_text: !0,
            back_text: "Back",
            mobile_show_parent_link: !0,
            is_hover: !0,
            scrolltop: !0,
            sticky_on: "all"
        },
        init: function(section, method, options) {
            Foundation.inherit(this, "add_custom_rule register_media throttle");
            var self = this;
            self.register_media("topbar", "foundation-mq-topbar"), this.bindings(method, options), 
            self.S("[" + this.attr_name() + "]", this.scope).each(function() {
                {
                    var topbar = $(this), settings = topbar.data(self.attr_name(!0) + "-init");
                    self.S("section, .top-bar-section", this);
                }
                topbar.data("index", 0);
                var topbarContainer = topbar.parent();
                topbarContainer.hasClass("fixed") || self.is_sticky(topbar, topbarContainer, settings) ? (self.settings.sticky_class = settings.sticky_class, 
                self.settings.sticky_topbar = topbar, topbar.data("height", topbarContainer.outerHeight()), 
                topbar.data("stickyoffset", topbarContainer.offset().top)) : topbar.data("height", topbar.outerHeight()), 
                settings.assembled || self.assemble(topbar), settings.is_hover ? self.S(".has-dropdown", topbar).addClass("not-click") : self.S(".has-dropdown", topbar).removeClass("not-click"), 
                self.add_custom_rule(".f-topbar-fixed { padding-top: " + topbar.data("height") + "px }"), 
                topbarContainer.hasClass("fixed") && self.S("body").addClass("f-topbar-fixed");
            });
        },
        is_sticky: function(topbar, topbarContainer, settings) {
            var sticky = topbarContainer.hasClass(settings.sticky_class);
            return sticky && "all" === settings.sticky_on ? !0 : sticky && this.small() && "small" === settings.sticky_on ? matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches && !matchMedia(Foundation.media_queries.large).matches : sticky && this.medium() && "medium" === settings.sticky_on ? matchMedia(Foundation.media_queries.small).matches && matchMedia(Foundation.media_queries.medium).matches && !matchMedia(Foundation.media_queries.large).matches : sticky && this.large() && "large" === settings.sticky_on ? matchMedia(Foundation.media_queries.small).matches && matchMedia(Foundation.media_queries.medium).matches && matchMedia(Foundation.media_queries.large).matches : !1;
        },
        toggle: function(toggleEl) {
            var topbar, self = this;
            topbar = toggleEl ? self.S(toggleEl).closest("[" + this.attr_name() + "]") : self.S("[" + this.attr_name() + "]");
            var settings = topbar.data(this.attr_name(!0) + "-init"), section = self.S("section, .top-bar-section", topbar);
            self.breakpoint() && (self.rtl ? (section.css({
                right: "0%"
            }), $(">.name", section).css({
                right: "100%"
            })) : (section.css({
                left: "0%"
            }), $(">.name", section).css({
                left: "100%"
            })), self.S("li.moved", section).removeClass("moved"), topbar.data("index", 0), 
            topbar.toggleClass("expanded").css("height", "")), settings.scrolltop ? topbar.hasClass("expanded") ? topbar.parent().hasClass("fixed") && (settings.scrolltop ? (topbar.parent().removeClass("fixed"), 
            topbar.addClass("fixed"), self.S("body").removeClass("f-topbar-fixed"), window.scrollTo(0, 0)) : topbar.parent().removeClass("expanded")) : topbar.hasClass("fixed") && (topbar.parent().addClass("fixed"), 
            topbar.removeClass("fixed"), self.S("body").addClass("f-topbar-fixed")) : (self.is_sticky(topbar, topbar.parent(), settings) && topbar.parent().addClass("fixed"), 
            topbar.parent().hasClass("fixed") && (topbar.hasClass("expanded") ? (topbar.addClass("fixed"), 
            topbar.parent().addClass("expanded"), self.S("body").addClass("f-topbar-fixed")) : (topbar.removeClass("fixed"), 
            topbar.parent().removeClass("expanded"), self.update_sticky_positioning())));
        },
        timer: null,
        events: function() {
            var self = this, S = this.S;
            S(this.scope).off(".topbar").on("click.fndtn.topbar", "[" + this.attr_name() + "] .toggle-topbar", function(e) {
                e.preventDefault(), self.toggle(this);
            }).on("click.fndtn.topbar", '.top-bar .top-bar-section li a[href^="#"],[' + this.attr_name() + '] .top-bar-section li a[href^="#"]', function() {
                var li = $(this).closest("li");
                !self.breakpoint() || li.hasClass("back") || li.hasClass("has-dropdown") || self.toggle();
            }).on("click.fndtn.topbar", "[" + this.attr_name() + "] li.has-dropdown", function(e) {
                var li = S(this), target = S(e.target), topbar = li.closest("[" + self.attr_name() + "]"), settings = topbar.data(self.attr_name(!0) + "-init");
                return target.data("revealId") ? void self.toggle() : void (self.breakpoint() || (!settings.is_hover || Modernizr.touch) && (e.stopImmediatePropagation(), 
                li.hasClass("hover") ? (li.removeClass("hover").find("li").removeClass("hover"), 
                li.parents("li.hover").removeClass("hover")) : (li.addClass("hover"), $(li).siblings().removeClass("hover"), 
                "A" === target[0].nodeName && target.parent().hasClass("has-dropdown") && e.preventDefault())));
            }).on("click.fndtn.topbar", "[" + this.attr_name() + "] .has-dropdown>a", function(e) {
                if (self.breakpoint()) {
                    e.preventDefault();
                    var $this = S(this), topbar = $this.closest("[" + self.attr_name() + "]"), section = topbar.find("section, .top-bar-section"), $selectedLi = ($this.next(".dropdown").outerHeight(), 
                    $this.closest("li"));
                    topbar.data("index", topbar.data("index") + 1), $selectedLi.addClass("moved"), self.rtl ? (section.css({
                        right: -(100 * topbar.data("index")) + "%"
                    }), section.find(">.name").css({
                        right: 100 * topbar.data("index") + "%"
                    })) : (section.css({
                        left: -(100 * topbar.data("index")) + "%"
                    }), section.find(">.name").css({
                        left: 100 * topbar.data("index") + "%"
                    })), topbar.css("height", $this.siblings("ul").outerHeight(!0) + topbar.data("height"));
                }
            }), S(window).off(".topbar").on("resize.fndtn.topbar", self.throttle(function() {
                self.resize.call(self);
            }, 50)).trigger("resize").trigger("resize.fndtn.topbar").load(function() {
                S(this).trigger("resize.fndtn.topbar");
            }), S("body").off(".topbar").on("click.fndtn.topbar", function(e) {
                var parent = S(e.target).closest("li").closest("li.hover");
                parent.length > 0 || S("[" + self.attr_name() + "] li.hover").removeClass("hover");
            }), S(this.scope).on("click.fndtn.topbar", "[" + this.attr_name() + "] .has-dropdown .back", function(e) {
                e.preventDefault();
                var $this = S(this), topbar = $this.closest("[" + self.attr_name() + "]"), section = topbar.find("section, .top-bar-section"), $movedLi = (topbar.data(self.attr_name(!0) + "-init"), 
                $this.closest("li.moved")), $previousLevelUl = $movedLi.parent();
                topbar.data("index", topbar.data("index") - 1), self.rtl ? (section.css({
                    right: -(100 * topbar.data("index")) + "%"
                }), section.find(">.name").css({
                    right: 100 * topbar.data("index") + "%"
                })) : (section.css({
                    left: -(100 * topbar.data("index")) + "%"
                }), section.find(">.name").css({
                    left: 100 * topbar.data("index") + "%"
                })), 0 === topbar.data("index") ? topbar.css("height", "") : topbar.css("height", $previousLevelUl.outerHeight(!0) + topbar.data("height")), 
                setTimeout(function() {
                    $movedLi.removeClass("moved");
                }, 300);
            }), S(this.scope).find(".dropdown a").focus(function() {
                $(this).parents(".has-dropdown").addClass("hover");
            }).blur(function() {
                $(this).parents(".has-dropdown").removeClass("hover");
            });
        },
        resize: function() {
            var self = this;
            self.S("[" + this.attr_name() + "]").each(function() {
                var stickyOffset, topbar = self.S(this), settings = topbar.data(self.attr_name(!0) + "-init"), stickyContainer = topbar.parent("." + self.settings.sticky_class);
                if (!self.breakpoint()) {
                    var doToggle = topbar.hasClass("expanded");
                    topbar.css("height", "").removeClass("expanded").find("li").removeClass("hover"), 
                    doToggle && self.toggle(topbar);
                }
                self.is_sticky(topbar, stickyContainer, settings) && (stickyContainer.hasClass("fixed") ? (stickyContainer.removeClass("fixed"), 
                stickyOffset = stickyContainer.offset().top, self.S(document.body).hasClass("f-topbar-fixed") && (stickyOffset -= topbar.data("height")), 
                topbar.data("stickyoffset", stickyOffset), stickyContainer.addClass("fixed")) : (stickyOffset = stickyContainer.offset().top, 
                topbar.data("stickyoffset", stickyOffset)));
            });
        },
        breakpoint: function() {
            return !matchMedia(Foundation.media_queries.topbar).matches;
        },
        small: function() {
            return matchMedia(Foundation.media_queries.small).matches;
        },
        medium: function() {
            return matchMedia(Foundation.media_queries.medium).matches;
        },
        large: function() {
            return matchMedia(Foundation.media_queries.large).matches;
        },
        assemble: function(topbar) {
            var self = this, settings = topbar.data(this.attr_name(!0) + "-init"), section = self.S("section, .top-bar-section", topbar);
            section.detach(), self.S(".has-dropdown>a", section).each(function() {
                var $titleLi, $link = self.S(this), $dropdown = $link.siblings(".dropdown"), url = $link.attr("href");
                $dropdown.find(".title.back").length || ($titleLi = $(1 == settings.mobile_show_parent_link && url ? '<li class="title back js-generated"><h5><a href="javascript:void(0)"></a></h5></li><li class="parent-link show-for-small"><a class="parent-link js-generated" href="' + url + '">' + $link.html() + "</a></li>" : '<li class="title back js-generated"><h5><a href="javascript:void(0)"></a></h5>'), 
                $("h5>a", $titleLi).html(1 == settings.custom_back_text ? settings.back_text : "&laquo; " + $link.html()), 
                $dropdown.prepend($titleLi));
            }), section.appendTo(topbar), this.sticky(), this.assembled(topbar);
        },
        assembled: function(topbar) {
            topbar.data(this.attr_name(!0), $.extend({}, topbar.data(this.attr_name(!0)), {
                assembled: !0
            }));
        },
        height: function(ul) {
            var total = 0, self = this;
            return $("> li", ul).each(function() {
                total += self.S(this).outerHeight(!0);
            }), total;
        },
        sticky: function() {
            var self = this;
            this.S(window).on("scroll", function() {
                self.update_sticky_positioning();
            });
        },
        update_sticky_positioning: function() {
            var klass = "." + this.settings.sticky_class, $window = this.S(window), self = this;
            if (self.settings.sticky_topbar && self.is_sticky(this.settings.sticky_topbar, this.settings.sticky_topbar.parent(), this.settings)) {
                var distance = this.settings.sticky_topbar.data("stickyoffset");
                self.S(klass).hasClass("expanded") || ($window.scrollTop() > distance ? self.S(klass).hasClass("fixed") || (self.S(klass).addClass("fixed"), 
                self.S("body").addClass("f-topbar-fixed")) : $window.scrollTop() <= distance && self.S(klass).hasClass("fixed") && (self.S(klass).removeClass("fixed"), 
                self.S("body").removeClass("f-topbar-fixed")));
            }
        },
        off: function() {
            this.S(this.scope).off(".fndtn.topbar"), this.S(window).off(".fndtn.topbar");
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($) {
    "use strict";
    Foundation.libs.offcanvas = {
        name: "offcanvas",
        version: "5.4.7",
        settings: {
            open_method: "move",
            close_on_click: !1
        },
        init: function(scope, method, options) {
            this.bindings(method, options);
        },
        events: function() {
            var self = this, S = self.S, move_class = "", right_postfix = "", left_postfix = "";
            "move" === this.settings.open_method ? (move_class = "move-", right_postfix = "right", 
            left_postfix = "left") : "overlap_single" === this.settings.open_method ? (move_class = "offcanvas-overlap-", 
            right_postfix = "right", left_postfix = "left") : "overlap" === this.settings.open_method && (move_class = "offcanvas-overlap"), 
            S(this.scope).off(".offcanvas").on("click.fndtn.offcanvas", ".left-off-canvas-toggle", function(e) {
                self.click_toggle_class(e, move_class + right_postfix), "overlap" !== self.settings.open_method && S(".left-submenu").removeClass(move_class + right_postfix), 
                $(".left-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".left-off-canvas-menu a", function(e) {
                var settings = self.get_settings(e), parent = S(this).parent();
                !settings.close_on_click || parent.hasClass("has-submenu") || parent.hasClass("back") ? S(this).parent().hasClass("has-submenu") ? (e.preventDefault(), 
                S(this).siblings(".left-submenu").toggleClass(move_class + right_postfix)) : parent.hasClass("back") && (e.preventDefault(), 
                parent.parent().removeClass(move_class + right_postfix)) : (self.hide.call(self, move_class + right_postfix, self.get_wrapper(e)), 
                parent.parent().removeClass(move_class + right_postfix)), $(".left-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".right-off-canvas-toggle", function(e) {
                self.click_toggle_class(e, move_class + left_postfix), "overlap" !== self.settings.open_method && S(".right-submenu").removeClass(move_class + left_postfix), 
                $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".right-off-canvas-menu a", function(e) {
                var settings = self.get_settings(e), parent = S(this).parent();
                !settings.close_on_click || parent.hasClass("has-submenu") || parent.hasClass("back") ? S(this).parent().hasClass("has-submenu") ? (e.preventDefault(), 
                S(this).siblings(".right-submenu").toggleClass(move_class + left_postfix)) : parent.hasClass("back") && (e.preventDefault(), 
                parent.parent().removeClass(move_class + left_postfix)) : (self.hide.call(self, move_class + left_postfix, self.get_wrapper(e)), 
                parent.parent().removeClass(move_class + left_postfix)), $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".exit-off-canvas", function(e) {
                self.click_remove_class(e, move_class + left_postfix), S(".right-submenu").removeClass(move_class + left_postfix), 
                right_postfix && (self.click_remove_class(e, move_class + right_postfix), S(".left-submenu").removeClass(move_class + left_postfix)), 
                $(".right-off-canvas-toggle").attr("aria-expanded", "true");
            }).on("click.fndtn.offcanvas", ".exit-off-canvas", function(e) {
                self.click_remove_class(e, move_class + left_postfix), $(".left-off-canvas-toggle").attr("aria-expanded", "false"), 
                right_postfix && (self.click_remove_class(e, move_class + right_postfix), $(".right-off-canvas-toggle").attr("aria-expanded", "false"));
            });
        },
        toggle: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.is("." + class_name) ? this.hide(class_name, $off_canvas) : this.show(class_name, $off_canvas);
        },
        show: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.trigger("open").trigger("open.fndtn.offcanvas"), 
            $off_canvas.addClass(class_name);
        },
        hide: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper(), $off_canvas.trigger("close").trigger("close.fndtn.offcanvas"), 
            $off_canvas.removeClass(class_name);
        },
        click_toggle_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.toggle(class_name, $off_canvas);
        },
        click_remove_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.hide(class_name, $off_canvas);
        },
        get_settings: function(e) {
            var offcanvas = this.S(e.target).closest("[" + this.attr_name() + "]");
            return offcanvas.data(this.attr_name(!0) + "-init") || this.settings;
        },
        get_wrapper: function(e) {
            var $off_canvas = this.S(e ? e.target : this.scope).closest(".off-canvas-wrap");
            return 0 === $off_canvas.length && ($off_canvas = this.S(".off-canvas-wrap")), $off_canvas;
        },
        reflow: function() {}
    };
}(jQuery, window, window.document), function($) {
    $.fn.fitText = function(kompressor, options) {
        var compressor = kompressor || 1, settings = $.extend({
            minFontSize: Number.NEGATIVE_INFINITY,
            maxFontSize: Number.POSITIVE_INFINITY
        }, options);
        return this.each(function() {
            var $this = $(this), resizer = function() {
                $this.css("font-size", Math.max(Math.min($this.width() / (10 * compressor), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)));
            };
            resizer(), $(window).on("resize.fittext orientationchange.fittext", resizer);
        });
    };
}(jQuery), navigator.sayswho = function() {
    var tem, ua = navigator.userAgent, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    return /trident/i.test(M[1]) ? (tem = /\brv[ :]+(\d+)/g.exec(ua) || [], "IE " + (tem[1] || "")) : "Chrome" === M[1] && (tem = ua.match(/\bOPR\/(\d+)/), 
    null != tem) ? "Opera " + tem[1] : (M = M[2] ? [ M[1], M[2] ] : [ navigator.appName, navigator.appVersion, "-?" ], 
    null != (tem = ua.match(/version\/(\d+)/i)) && M.splice(1, 1, tem[1]), M.join(" "));
}();

var MobileEsp = {
    initCompleted: !1,
    isWebkit: !1,
    isMobilePhone: !1,
    isIphone: !1,
    isAndroid: !1,
    isAndroidPhone: !1,
    isTierTablet: !1,
    isTierIphone: !1,
    isTierRichCss: !1,
    isTierGenericMobile: !1,
    engineWebKit: "webkit",
    deviceIphone: "iphone",
    deviceIpod: "ipod",
    deviceIpad: "ipad",
    deviceMacPpc: "macintosh",
    deviceAndroid: "android",
    deviceGoogleTV: "googletv",
    deviceHtcFlyer: "htc_flyer",
    deviceWinPhone7: "windows phone os 7",
    deviceWinPhone8: "windows phone 8",
    deviceWinMob: "windows ce",
    deviceWindows: "windows",
    deviceIeMob: "iemobile",
    devicePpc: "ppc",
    enginePie: "wm5 pie",
    deviceBB: "blackberry",
    deviceBB10: "bb10",
    vndRIM: "vnd.rim",
    deviceBBStorm: "blackberry95",
    deviceBBBold: "blackberry97",
    deviceBBBoldTouch: "blackberry 99",
    deviceBBTour: "blackberry96",
    deviceBBCurve: "blackberry89",
    deviceBBCurveTouch: "blackberry 938",
    deviceBBTorch: "blackberry 98",
    deviceBBPlaybook: "playbook",
    deviceSymbian: "symbian",
    deviceSymbos: "symbos",
    deviceS60: "series60",
    deviceS70: "series70",
    deviceS80: "series80",
    deviceS90: "series90",
    devicePalm: "palm",
    deviceWebOS: "webos",
    deviceWebOShp: "hpwos",
    engineBlazer: "blazer",
    engineXiino: "xiino",
    deviceNuvifone: "nuvifone",
    deviceBada: "bada",
    deviceTizen: "tizen",
    deviceMeego: "meego",
    deviceKindle: "kindle",
    engineSilk: "silk-accelerated",
    vndwap: "vnd.wap",
    wml: "wml",
    deviceTablet: "tablet",
    deviceBrew: "brew",
    deviceDanger: "danger",
    deviceHiptop: "hiptop",
    devicePlaystation: "playstation",
    devicePlaystationVita: "vita",
    deviceNintendoDs: "nitro",
    deviceNintendo: "nintendo",
    deviceWii: "wii",
    deviceXbox: "xbox",
    deviceArchos: "archos",
    engineOpera: "opera",
    engineNetfront: "netfront",
    engineUpBrowser: "up.browser",
    engineOpenWeb: "openweb",
    deviceMidp: "midp",
    uplink: "up.link",
    engineTelecaQ: "teleca q",
    engineObigo: "obigo",
    devicePda: "pda",
    mini: "mini",
    mobile: "mobile",
    mobi: "mobi",
    maemo: "maemo",
    linux: "linux",
    mylocom2: "sony/com",
    manuSonyEricsson: "sonyericsson",
    manuericsson: "ericsson",
    manuSamsung1: "sec-sgh",
    manuSony: "sony",
    manuHtc: "htc",
    svcDocomo: "docomo",
    svcKddi: "kddi",
    svcVodafone: "vodafone",
    disUpdate: "update",
    uagent: "",
    InitDeviceScan: function() {
        this.initCompleted = !1, navigator && navigator.userAgent && (this.uagent = navigator.userAgent.toLowerCase()), 
        this.isWebkit = this.DetectWebkit(), this.isIphone = this.DetectIphone(), this.isAndroid = this.DetectAndroid(), 
        this.isAndroidPhone = this.DetectAndroidPhone(), this.isTierIphone = this.DetectTierIphone(), 
        this.isTierTablet = this.DetectTierTablet(), this.isMobilePhone = this.DetectMobileQuick(), 
        this.isTierRichCss = this.DetectTierRichCss(), this.isTierGenericMobile = this.DetectTierOtherPhones(), 
        this.initCompleted = !0;
    },
    DetectIphone: function() {
        return this.initCompleted || this.isIphone ? this.isIphone : this.uagent.search(this.deviceIphone) > -1 ? this.DetectIpad() || this.DetectIpod() ? !1 : !0 : !1;
    },
    DetectIpod: function() {
        return this.uagent.search(this.deviceIpod) > -1 ? !0 : !1;
    },
    DetectIphoneOrIpod: function() {
        return this.DetectIphone() || this.DetectIpod() ? !0 : !1;
    },
    DetectIpad: function() {
        return this.uagent.search(this.deviceIpad) > -1 && this.DetectWebkit() ? !0 : !1;
    },
    DetectIos: function() {
        return this.DetectIphoneOrIpod() || this.DetectIpad() ? !0 : !1;
    },
    DetectAndroid: function() {
        return this.initCompleted || this.isAndroid ? this.isAndroid : this.uagent.search(this.deviceAndroid) > -1 || this.DetectGoogleTV() ? !0 : this.uagent.search(this.deviceHtcFlyer) > -1 ? !0 : !1;
    },
    DetectAndroidPhone: function() {
        return this.initCompleted || this.isAndroidPhone ? this.isAndroidPhone : this.DetectAndroid() && this.uagent.search(this.mobile) > -1 ? !0 : this.DetectOperaAndroidPhone() ? !0 : this.uagent.search(this.deviceHtcFlyer) > -1 ? !0 : !1;
    },
    DetectAndroidTablet: function() {
        return this.DetectAndroid() ? this.DetectOperaMobile() ? !1 : this.uagent.search(this.deviceHtcFlyer) > -1 ? !1 : this.uagent.search(this.mobile) > -1 ? !1 : !0 : !1;
    },
    DetectAndroidWebKit: function() {
        return this.DetectAndroid() && this.DetectWebkit() ? !0 : !1;
    },
    DetectGoogleTV: function() {
        return this.uagent.search(this.deviceGoogleTV) > -1 ? !0 : !1;
    },
    DetectWebkit: function() {
        return this.initCompleted || this.isWebkit ? this.isWebkit : this.uagent.search(this.engineWebKit) > -1 ? !0 : !1;
    },
    DetectWindowsPhone: function() {
        return this.DetectWindowsPhone7() || this.DetectWindowsPhone8() ? !0 : !1;
    },
    DetectWindowsPhone7: function() {
        return this.uagent.search(this.deviceWinPhone7) > -1 ? !0 : !1;
    },
    DetectWindowsPhone8: function() {
        return this.uagent.search(this.deviceWinPhone8) > -1 ? !0 : !1;
    },
    DetectWindowsMobile: function() {
        return this.DetectWindowsPhone() ? !1 : this.uagent.search(this.deviceWinMob) > -1 || this.uagent.search(this.deviceIeMob) > -1 || this.uagent.search(this.enginePie) > -1 ? !0 : this.uagent.search(this.devicePpc) > -1 && !(this.uagent.search(this.deviceMacPpc) > -1) ? !0 : this.uagent.search(this.manuHtc) > -1 && this.uagent.search(this.deviceWindows) > -1 ? !0 : !1;
    },
    DetectBlackBerry: function() {
        return this.uagent.search(this.deviceBB) > -1 || this.uagent.search(this.vndRIM) > -1 ? !0 : this.DetectBlackBerry10Phone() ? !0 : !1;
    },
    DetectBlackBerry10Phone: function() {
        return this.uagent.search(this.deviceBB10) > -1 && this.uagent.search(this.mobile) > -1 ? !0 : !1;
    },
    DetectBlackBerryTablet: function() {
        return this.uagent.search(this.deviceBBPlaybook) > -1 ? !0 : !1;
    },
    DetectBlackBerryWebKit: function() {
        return this.DetectBlackBerry() && this.uagent.search(this.engineWebKit) > -1 ? !0 : !1;
    },
    DetectBlackBerryTouch: function() {
        return this.DetectBlackBerry() && (this.uagent.search(this.deviceBBStorm) > -1 || this.uagent.search(this.deviceBBTorch) > -1 || this.uagent.search(this.deviceBBBoldTouch) > -1 || this.uagent.search(this.deviceBBCurveTouch) > -1) ? !0 : !1;
    },
    DetectBlackBerryHigh: function() {
        return this.DetectBlackBerryWebKit() ? !1 : this.DetectBlackBerry() && (this.DetectBlackBerryTouch() || this.uagent.search(this.deviceBBBold) > -1 || this.uagent.search(this.deviceBBTour) > -1 || this.uagent.search(this.deviceBBCurve) > -1) ? !0 : !1;
    },
    DetectBlackBerryLow: function() {
        return this.DetectBlackBerry() ? this.DetectBlackBerryHigh() || this.DetectBlackBerryWebKit() ? !1 : !0 : !1;
    },
    DetectS60OssBrowser: function() {
        return this.DetectWebkit() && (this.uagent.search(this.deviceS60) > -1 || this.uagent.search(this.deviceSymbian) > -1) ? !0 : !1;
    },
    DetectSymbianOS: function() {
        return this.uagent.search(this.deviceSymbian) > -1 || this.uagent.search(this.deviceS60) > -1 || this.uagent.search(this.deviceSymbos) > -1 && this.DetectOperaMobile || this.uagent.search(this.deviceS70) > -1 || this.uagent.search(this.deviceS80) > -1 || this.uagent.search(this.deviceS90) > -1 ? !0 : !1;
    },
    DetectPalmOS: function() {
        return this.DetectPalmWebOS() ? !1 : this.uagent.search(this.devicePalm) > -1 || this.uagent.search(this.engineBlazer) > -1 || this.uagent.search(this.engineXiino) > -1 ? !0 : !1;
    },
    DetectPalmWebOS: function() {
        return this.uagent.search(this.deviceWebOS) > -1 ? !0 : !1;
    },
    DetectWebOSTablet: function() {
        return this.uagent.search(this.deviceWebOShp) > -1 && this.uagent.search(this.deviceTablet) > -1 ? !0 : !1;
    },
    DetectOperaMobile: function() {
        return this.uagent.search(this.engineOpera) > -1 && (this.uagent.search(this.mini) > -1 || this.uagent.search(this.mobi) > -1) ? !0 : !1;
    },
    DetectOperaAndroidPhone: function() {
        return this.uagent.search(this.engineOpera) > -1 && this.uagent.search(this.deviceAndroid) > -1 && this.uagent.search(this.mobi) > -1 ? !0 : !1;
    },
    DetectOperaAndroidTablet: function() {
        return this.uagent.search(this.engineOpera) > -1 && this.uagent.search(this.deviceAndroid) > -1 && this.uagent.search(this.deviceTablet) > -1 ? !0 : !1;
    },
    DetectKindle: function() {
        return this.uagent.search(this.deviceKindle) > -1 && !this.DetectAndroid() ? !0 : !1;
    },
    DetectAmazonSilk: function() {
        return this.uagent.search(this.engineSilk) > -1 ? !0 : !1;
    },
    DetectGarminNuvifone: function() {
        return this.uagent.search(this.deviceNuvifone) > -1 ? !0 : !1;
    },
    DetectBada: function() {
        return this.uagent.search(this.deviceBada) > -1 ? !0 : !1;
    },
    DetectTizen: function() {
        return this.uagent.search(this.deviceTizen) > -1 ? !0 : !1;
    },
    DetectMeego: function() {
        return this.uagent.search(this.deviceMeego) > -1 ? !0 : !1;
    },
    DetectDangerHiptop: function() {
        return this.uagent.search(this.deviceDanger) > -1 || this.uagent.search(this.deviceHiptop) > -1 ? !0 : !1;
    },
    DetectSonyMylo: function() {
        return this.uagent.search(this.manuSony) > -1 && (this.uagent.search(this.qtembedded) > -1 || this.uagent.search(this.mylocom2) > -1) ? !0 : !1;
    },
    DetectMaemoTablet: function() {
        return this.uagent.search(this.maemo) > -1 ? !0 : this.uagent.search(this.linux) > -1 && this.uagent.search(this.deviceTablet) > -1 && !this.DetectWebOSTablet() && !this.DetectAndroid() ? !0 : !1;
    },
    DetectArchos: function() {
        return this.uagent.search(this.deviceArchos) > -1 ? !0 : !1;
    },
    DetectGameConsole: function() {
        return this.DetectSonyPlaystation() || this.DetectNintendo() || this.DetectXbox() ? !0 : !1;
    },
    DetectSonyPlaystation: function() {
        return this.uagent.search(this.devicePlaystation) > -1 ? !0 : !1;
    },
    DetectGamingHandheld: function() {
        return this.uagent.search(this.devicePlaystation) > -1 && this.uagent.search(this.devicePlaystationVita) > -1 ? !0 : !1;
    },
    DetectNintendo: function() {
        return this.uagent.search(this.deviceNintendo) > -1 || this.uagent.search(this.deviceWii) > -1 || this.uagent.search(this.deviceNintendoDs) > -1 ? !0 : !1;
    },
    DetectXbox: function() {
        return this.uagent.search(this.deviceXbox) > -1 ? !0 : !1;
    },
    DetectBrewDevice: function() {
        return this.uagent.search(this.deviceBrew) > -1 ? !0 : !1;
    },
    DetectSmartphone: function() {
        return this.DetectTierIphone() || this.DetectS60OssBrowser() || this.DetectSymbianOS() || this.DetectWindowsMobile() || this.DetectBlackBerry() || this.DetectPalmOS() ? !0 : !1;
    },
    DetectMobileQuick: function() {
        return this.DetectTierTablet() ? !1 : this.initCompleted || this.isMobilePhone ? this.isMobilePhone : this.DetectSmartphone() ? !0 : this.uagent.search(this.mobile) > -1 ? !0 : this.DetectKindle() || this.DetectAmazonSilk() ? !0 : this.uagent.search(this.deviceMidp) > -1 || this.DetectBrewDevice() ? !0 : this.DetectOperaMobile() || this.DetectArchos() ? !0 : this.uagent.search(this.engineObigo) > -1 || this.uagent.search(this.engineNetfront) > -1 || this.uagent.search(this.engineUpBrowser) > -1 || this.uagent.search(this.engineOpenWeb) > -1 ? !0 : !1;
    },
    DetectMobileLong: function() {
        return this.DetectMobileQuick() ? !0 : this.DetectGameConsole() ? !0 : this.DetectDangerHiptop() || this.DetectMaemoTablet() || this.DetectSonyMylo() || this.DetectGarminNuvifone() ? !0 : this.uagent.search(this.devicePda) > -1 && !(this.uagent.search(this.disUpdate) > -1) ? !0 : this.uagent.search(this.manuSamsung1) > -1 || this.uagent.search(this.manuSonyEricsson) > -1 || this.uagent.search(this.manuericsson) > -1 ? !0 : this.uagent.search(this.svcDocomo) > -1 || this.uagent.search(this.svcKddi) > -1 || this.uagent.search(this.svcVodafone) > -1 ? !0 : !1;
    },
    DetectTierTablet: function() {
        return this.initCompleted || this.isTierTablet ? this.isTierTablet : this.DetectIpad() || this.DetectAndroidTablet() || this.DetectBlackBerryTablet() || this.DetectWebOSTablet() ? !0 : !1;
    },
    DetectTierIphone: function() {
        return this.initCompleted || this.isTierIphone ? this.isTierIphone : this.DetectIphoneOrIpod() || this.DetectAndroidPhone() || this.DetectWindowsPhone() || this.DetectBlackBerry10Phone() || this.DetectPalmWebOS() || this.DetectBada() || this.DetectTizen() || this.DetectGamingHandheld() ? !0 : this.DetectBlackBerryWebKit() && this.DetectBlackBerryTouch() ? !0 : !1;
    },
    DetectTierRichCss: function() {
        return this.initCompleted || this.isTierRichCss ? this.isTierRichCss : this.DetectTierIphone() || this.DetectKindle() || this.DetectTierTablet() ? !1 : this.DetectMobileQuick() ? this.DetectWebkit() ? !0 : this.DetectS60OssBrowser() || this.DetectBlackBerryHigh() || this.DetectWindowsMobile() || this.uagent.search(this.engineTelecaQ) > -1 ? !0 : !1 : !1;
    },
    DetectTierOtherPhones: function() {
        return this.initCompleted || this.isTierGenericMobile ? this.isTierGenericMobile : this.DetectTierIphone() || this.DetectTierRichCss() || this.DetectTierTablet() ? !1 : this.DetectMobileLong() ? !0 : !1;
    }
};

MobileEsp.InitDeviceScan();

var isMobile = {
    Android: function() {
        return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i);
    },
    iOS: function() {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function() {
        return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function() {
        return navigator.userAgent.match(/IEMobile/i);
    },
    any: function() {
        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
    }
};

jQuery.fn.makeSQ = function(cb) {
    var _e = jQuery(this), _eW = _e.outerWidth();
    _e.css({
        width: _eW,
        height: _eW
    }), "function" == typeof cb && cb();
}, jQuery.fn.winHW = function(ele, h, w, cb) {
    var _e = jQuery(this), _w = jQuery(window), winH = _w.height(), winW = _w.width();
    h && _e.height(winH + "px"), w && _e.width(winW + "px"), "function" == typeof cb && cb();
}, function() {
    function createReduce(dir) {
        function iterator(obj, iteratee, memo, keys, index, length) {
            for (;index >= 0 && length > index; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        }
        return function(obj, iteratee, memo, context) {
            iteratee = optimizeCb(iteratee, context, 4);
            var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
            return arguments.length < 3 && (memo = obj[keys ? keys[index] : index], index += dir), 
            iterator(obj, iteratee, memo, keys, index, length);
        };
    }
    function createIndexFinder(dir) {
        return function(array, predicate, context) {
            predicate = cb(predicate, context);
            for (var length = null != array && array.length, index = dir > 0 ? 0 : length - 1; index >= 0 && length > index; index += dir) if (predicate(array[index], index, array)) return index;
            return -1;
        };
    }
    function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length, constructor = obj.constructor, proto = _.isFunction(constructor) && constructor.prototype || ObjProto, prop = "constructor";
        for (_.has(obj, prop) && !_.contains(keys, prop) && keys.push(prop); nonEnumIdx--; ) prop = nonEnumerableProps[nonEnumIdx], 
        prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop) && keys.push(prop);
    }
    var root = this, previousUnderscore = root._, ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype, push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create, Ctor = function() {}, _ = function(obj) {
        return obj instanceof _ ? obj : this instanceof _ ? void (this._wrapped = obj) : new _(obj);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = _), 
    exports._ = _) : root._ = _, _.VERSION = "1.8.2";
    var optimizeCb = function(func, context, argCount) {
        if (void 0 === context) return func;
        switch (null == argCount ? 3 : argCount) {
          case 1:
            return function(value) {
                return func.call(context, value);
            };

          case 2:
            return function(value, other) {
                return func.call(context, value, other);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
            return func.apply(context, arguments);
        };
    }, cb = function(value, context, argCount) {
        return null == value ? _.identity : _.isFunction(value) ? optimizeCb(value, context, argCount) : _.isObject(value) ? _.matcher(value) : _.property(value);
    };
    _.iteratee = function(value, context) {
        return cb(value, context, 1/0);
    };
    var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
            var length = arguments.length;
            if (2 > length || null == obj) return obj;
            for (var index = 1; length > index; index++) for (var source = arguments[index], keys = keysFunc(source), l = keys.length, i = 0; l > i; i++) {
                var key = keys[i];
                undefinedOnly && void 0 !== obj[key] || (obj[key] = source[key]);
            }
            return obj;
        };
    }, baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor();
        return Ctor.prototype = null, result;
    }, MAX_ARRAY_INDEX = Math.pow(2, 53) - 1, isArrayLike = function(collection) {
        var length = collection && collection.length;
        return "number" == typeof length && length >= 0 && MAX_ARRAY_INDEX >= length;
    };
    _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) for (i = 0, length = obj.length; length > i; i++) iteratee(obj[i], i, obj); else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; length > i; i++) iteratee(obj[keys[i]], keys[i], obj);
        }
        return obj;
    }, _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length), index = 0; length > index; index++) {
            var currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    }, _.reduce = _.foldl = _.inject = createReduce(1), _.reduceRight = _.foldr = createReduce(-1), 
    _.find = _.detect = function(obj, predicate, context) {
        var key;
        return key = isArrayLike(obj) ? _.findIndex(obj, predicate, context) : _.findKey(obj, predicate, context), 
        void 0 !== key && -1 !== key ? obj[key] : void 0;
    }, _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        return predicate = cb(predicate, context), _.each(obj, function(value, index, list) {
            predicate(value, index, list) && results.push(value);
        }), results;
    }, _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
    }, _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = 0; length > index; index++) {
            var currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj)) return !1;
        }
        return !0;
    }, _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = 0; length > index; index++) {
            var currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj)) return !0;
        }
        return !1;
    }, _.contains = _.includes = _.include = function(obj, target, fromIndex) {
        return isArrayLike(obj) || (obj = _.values(obj)), _.indexOf(obj, target, "number" == typeof fromIndex && fromIndex) >= 0;
    }, _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2), isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            var func = isFunc ? method : value[method];
            return null == func ? func : func.apply(value, args);
        });
    }, _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    }, _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
    }, _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
    }, _.max = function(obj, iteratee, context) {
        var value, computed, result = -1/0, lastComputed = -1/0;
        if (null == iteratee && null != obj) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], value > result && (result = value);
        } else iteratee = cb(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (computed > lastComputed || computed === -1/0 && result === -1/0) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.min = function(obj, iteratee, context) {
        var value, computed, result = 1/0, lastComputed = 1/0;
        if (null == iteratee && null != obj) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], result > value && (result = value);
        } else iteratee = cb(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (lastComputed > computed || 1/0 === computed && 1/0 === result) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.shuffle = function(obj) {
        for (var rand, set = isArrayLike(obj) ? obj : _.values(obj), length = set.length, shuffled = Array(length), index = 0; length > index; index++) rand = _.random(0, index), 
        rand !== index && (shuffled[index] = shuffled[rand]), shuffled[rand] = set[index];
        return shuffled;
    }, _.sample = function(obj, n, guard) {
        return null == n || guard ? (isArrayLike(obj) || (obj = _.values(obj)), obj[_.random(obj.length - 1)]) : _.shuffle(obj).slice(0, Math.max(0, n));
    }, _.sortBy = function(obj, iteratee, context) {
        return iteratee = cb(iteratee, context), _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iteratee(value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria, b = right.criteria;
            if (a !== b) {
                if (a > b || void 0 === a) return 1;
                if (b > a || void 0 === b) return -1;
            }
            return left.index - right.index;
        }), "value");
    };
    var group = function(behavior) {
        return function(obj, iteratee, context) {
            var result = {};
            return iteratee = cb(iteratee, context), _.each(obj, function(value, index) {
                var key = iteratee(value, index, obj);
                behavior(result, value, key);
            }), result;
        };
    };
    _.groupBy = group(function(result, value, key) {
        _.has(result, key) ? result[key].push(value) : result[key] = [ value ];
    }), _.indexBy = group(function(result, value, key) {
        result[key] = value;
    }), _.countBy = group(function(result, value, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
    }), _.toArray = function(obj) {
        return obj ? _.isArray(obj) ? slice.call(obj) : isArrayLike(obj) ? _.map(obj, _.identity) : _.values(obj) : [];
    }, _.size = function(obj) {
        return null == obj ? 0 : isArrayLike(obj) ? obj.length : _.keys(obj).length;
    }, _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        return _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
        }), [ pass, fail ];
    }, _.first = _.head = _.take = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[0] : _.initial(array, array.length - n);
    }, _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)));
    }, _.last = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[array.length - 1] : _.rest(array, Math.max(0, array.length - n));
    }, _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, null == n || guard ? 1 : n);
    }, _.compact = function(array) {
        return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, startIndex) {
        for (var output = [], idx = 0, i = startIndex || 0, length = input && input.length; length > i; i++) {
            var value = input[i];
            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                shallow || (value = flatten(value, shallow, strict));
                var j = 0, len = value.length;
                for (output.length += len; len > j; ) output[idx++] = value[j++];
            } else strict || (output[idx++] = value);
        }
        return output;
    };
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, !1);
    }, _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    }, _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (null == array) return [];
        _.isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), 
        null != iteratee && (iteratee = cb(iteratee, context));
        for (var result = [], seen = [], i = 0, length = array.length; length > i; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            isSorted ? (i && seen === computed || result.push(value), seen = computed) : iteratee ? _.contains(seen, computed) || (seen.push(computed), 
            result.push(value)) : _.contains(result, value) || result.push(value);
        }
        return result;
    }, _.union = function() {
        return _.uniq(flatten(arguments, !0, !0));
    }, _.intersection = function(array) {
        if (null == array) return [];
        for (var result = [], argsLength = arguments.length, i = 0, length = array.length; length > i; i++) {
            var item = array[i];
            if (!_.contains(result, item)) {
                for (var j = 1; argsLength > j && _.contains(arguments[j], item); j++) ;
                j === argsLength && result.push(item);
            }
        }
        return result;
    }, _.difference = function(array) {
        var rest = flatten(arguments, !0, !0, 1);
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    }, _.zip = function() {
        return _.unzip(arguments);
    }, _.unzip = function(array) {
        for (var length = array && _.max(array, "length").length || 0, result = Array(length), index = 0; length > index; index++) result[index] = _.pluck(array, index);
        return result;
    }, _.object = function(list, values) {
        for (var result = {}, i = 0, length = list && list.length; length > i; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
        return result;
    }, _.indexOf = function(array, item, isSorted) {
        var i = 0, length = array && array.length;
        if ("number" == typeof isSorted) i = 0 > isSorted ? Math.max(0, length + isSorted) : isSorted; else if (isSorted && length) return i = _.sortedIndex(array, item), 
        array[i] === item ? i : -1;
        if (item !== item) return _.findIndex(slice.call(array, i), _.isNaN);
        for (;length > i; i++) if (array[i] === item) return i;
        return -1;
    }, _.lastIndexOf = function(array, item, from) {
        var idx = array ? array.length : 0;
        if ("number" == typeof from && (idx = 0 > from ? idx + from + 1 : Math.min(idx, from + 1)), 
        item !== item) return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
        for (;--idx >= 0; ) if (array[idx] === item) return idx;
        return -1;
    }, _.findIndex = createIndexFinder(1), _.findLastIndex = createIndexFinder(-1), 
    _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        for (var value = iteratee(obj), low = 0, high = array.length; high > low; ) {
            var mid = Math.floor((low + high) / 2);
            iteratee(array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    }, _.range = function(start, stop, step) {
        arguments.length <= 1 && (stop = start || 0, start = 0), step = step || 1;
        for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; length > idx; idx++, 
        start += step) range[idx] = start;
        return range;
    };
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype), result = sourceFunc.apply(self, args);
        return _.isObject(result) ? result : self;
    };
    _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
        var args = slice.call(arguments, 2), bound = function() {
            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
    }, _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1), bound = function() {
            for (var position = 0, length = boundArgs.length, args = Array(length), i = 0; length > i; i++) args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
            for (;position < arguments.length; ) args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
        };
        return bound;
    }, _.bindAll = function(obj) {
        var i, key, length = arguments.length;
        if (1 >= length) throw new Error("bindAll must be passed function names");
        for (i = 1; length > i; i++) key = arguments[i], obj[key] = _.bind(obj[key], obj);
        return obj;
    }, _.memoize = function(func, hasher) {
        var memoize = function(key) {
            var cache = memoize.cache, address = "" + (hasher ? hasher.apply(this, arguments) : key);
            return _.has(cache, address) || (cache[address] = func.apply(this, arguments)), 
            cache[address];
        };
        return memoize.cache = {}, memoize;
    }, _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    }, _.defer = _.partial(_.delay, _, 1), _.throttle = function(func, wait, options) {
        var context, args, result, timeout = null, previous = 0;
        options || (options = {});
        var later = function() {
            previous = options.leading === !1 ? 0 : _.now(), timeout = null, result = func.apply(context, args), 
            timeout || (context = args = null);
        };
        return function() {
            var now = _.now();
            previous || options.leading !== !1 || (previous = now);
            var remaining = wait - (now - previous);
            return context = this, args = arguments, 0 >= remaining || remaining > wait ? (timeout && (clearTimeout(timeout), 
            timeout = null), previous = now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining)), 
            result;
        };
    }, _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result, later = function() {
            var last = _.now() - timestamp;
            wait > last && last >= 0 ? timeout = setTimeout(later, wait - last) : (timeout = null, 
            immediate || (result = func.apply(context, args), timeout || (context = args = null)));
        };
        return function() {
            context = this, args = arguments, timestamp = _.now();
            var callNow = immediate && !timeout;
            return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args), 
            context = args = null), result;
        };
    }, _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    }, _.negate = function(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    }, _.compose = function() {
        var args = arguments, start = args.length - 1;
        return function() {
            for (var i = start, result = args[start].apply(this, arguments); i--; ) result = args[i].call(this, result);
            return result;
        };
    }, _.after = function(times, func) {
        return function() {
            return --times < 1 ? func.apply(this, arguments) : void 0;
        };
    }, _.before = function(times, func) {
        var memo;
        return function() {
            return --times > 0 && (memo = func.apply(this, arguments)), 1 >= times && (func = null), 
            memo;
        };
    }, _.once = _.partial(_.before, 2);
    var hasEnumBug = !{
        toString: null
    }.propertyIsEnumerable("toString"), nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
    _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) _.has(obj, key) && keys.push(key);
        return hasEnumBug && collectNonEnumProps(obj, keys), keys;
    }, _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        return hasEnumBug && collectNonEnumProps(obj, keys), keys;
    }, _.values = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, values = Array(length), i = 0; length > i; i++) values[i] = obj[keys[i]];
        return values;
    }, _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        for (var currentKey, keys = _.keys(obj), length = keys.length, results = {}, index = 0; length > index; index++) currentKey = keys[index], 
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        return results;
    }, _.pairs = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, pairs = Array(length), i = 0; length > i; i++) pairs[i] = [ keys[i], obj[keys[i]] ];
        return pairs;
    }, _.invert = function(obj) {
        for (var result = {}, keys = _.keys(obj), i = 0, length = keys.length; length > i; i++) result[obj[keys[i]]] = keys[i];
        return result;
    }, _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) _.isFunction(obj[key]) && names.push(key);
        return names.sort();
    }, _.extend = createAssigner(_.allKeys), _.extendOwn = _.assign = createAssigner(_.keys), 
    _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        for (var key, keys = _.keys(obj), i = 0, length = keys.length; length > i; i++) if (key = keys[i], 
        predicate(obj[key], key, obj)) return key;
    }, _.pick = function(object, oiteratee, context) {
        var iteratee, keys, result = {}, obj = object;
        if (null == obj) return result;
        _.isFunction(oiteratee) ? (keys = _.allKeys(obj), iteratee = optimizeCb(oiteratee, context)) : (keys = flatten(arguments, !1, !1, 1), 
        iteratee = function(value, key, obj) {
            return key in obj;
        }, obj = Object(obj));
        for (var i = 0, length = keys.length; length > i; i++) {
            var key = keys[i], value = obj[key];
            iteratee(value, key, obj) && (result[key] = value);
        }
        return result;
    }, _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) iteratee = _.negate(iteratee); else {
            var keys = _.map(flatten(arguments, !1, !1, 1), String);
            iteratee = function(value, key) {
                return !_.contains(keys, key);
            };
        }
        return _.pick(obj, iteratee, context);
    }, _.defaults = createAssigner(_.allKeys, !0), _.clone = function(obj) {
        return _.isObject(obj) ? _.isArray(obj) ? obj.slice() : _.extend({}, obj) : obj;
    }, _.tap = function(obj, interceptor) {
        return interceptor(obj), obj;
    }, _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (null == object) return !length;
        for (var obj = Object(object), i = 0; length > i; i++) {
            var key = keys[i];
            if (attrs[key] !== obj[key] || !(key in obj)) return !1;
        }
        return !0;
    };
    var eq = function(a, b, aStack, bStack) {
        if (a === b) return 0 !== a || 1 / a === 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof _ && (a = a._wrapped), b instanceof _ && (b = b._wrapped);
        var className = toString.call(a);
        if (className !== toString.call(b)) return !1;
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a == "" + b;

          case "[object Number]":
            return +a !== +a ? +b !== +b : 0 === +a ? 1 / +a === 1 / b : +a === +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
        }
        var areArrays = "[object Array]" === className;
        if (!areArrays) {
            if ("object" != typeof a || "object" != typeof b) return !1;
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return !1;
        }
        aStack = aStack || [], bStack = bStack || [];
        for (var length = aStack.length; length--; ) if (aStack[length] === a) return bStack[length] === b;
        if (aStack.push(a), bStack.push(b), areArrays) {
            if (length = a.length, length !== b.length) return !1;
            for (;length--; ) if (!eq(a[length], b[length], aStack, bStack)) return !1;
        } else {
            var key, keys = _.keys(a);
            if (length = keys.length, _.keys(b).length !== length) return !1;
            for (;length--; ) if (key = keys[length], !_.has(b, key) || !eq(a[key], b[key], aStack, bStack)) return !1;
        }
        return aStack.pop(), bStack.pop(), !0;
    };
    _.isEqual = function(a, b) {
        return eq(a, b);
    }, _.isEmpty = function(obj) {
        return null == obj ? !0 : isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) ? 0 === obj.length : 0 === _.keys(obj).length;
    }, _.isElement = function(obj) {
        return !(!obj || 1 !== obj.nodeType);
    }, _.isArray = nativeIsArray || function(obj) {
        return "[object Array]" === toString.call(obj);
    }, _.isObject = function(obj) {
        var type = typeof obj;
        return "function" === type || "object" === type && !!obj;
    }, _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) === "[object " + name + "]";
        };
    }), _.isArguments(arguments) || (_.isArguments = function(obj) {
        return _.has(obj, "callee");
    }), "function" != typeof /./ && "object" != typeof Int8Array && (_.isFunction = function(obj) {
        return "function" == typeof obj || !1;
    }), _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    }, _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
    }, _.isBoolean = function(obj) {
        return obj === !0 || obj === !1 || "[object Boolean]" === toString.call(obj);
    }, _.isNull = function(obj) {
        return null === obj;
    }, _.isUndefined = function(obj) {
        return void 0 === obj;
    }, _.has = function(obj, key) {
        return null != obj && hasOwnProperty.call(obj, key);
    }, _.noConflict = function() {
        return root._ = previousUnderscore, this;
    }, _.identity = function(value) {
        return value;
    }, _.constant = function(value) {
        return function() {
            return value;
        };
    }, _.noop = function() {}, _.property = function(key) {
        return function(obj) {
            return null == obj ? void 0 : obj[key];
        };
    }, _.propertyOf = function(obj) {
        return null == obj ? function() {} : function(key) {
            return obj[key];
        };
    }, _.matcher = _.matches = function(attrs) {
        return attrs = _.extendOwn({}, attrs), function(obj) {
            return _.isMatch(obj, attrs);
        };
    }, _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; n > i; i++) accum[i] = iteratee(i);
        return accum;
    }, _.random = function(min, max) {
        return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1));
    }, _.now = Date.now || function() {
        return new Date().getTime();
    };
    var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, unescapeMap = _.invert(escapeMap), createEscaper = function(map) {
        var escaper = function(match) {
            return map[match];
        }, source = "(?:" + _.keys(map).join("|") + ")", testRegexp = RegExp(source), replaceRegexp = RegExp(source, "g");
        return function(string) {
            return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    };
    _.escape = createEscaper(escapeMap), _.unescape = createEscaper(unescapeMap), _.result = function(object, property, fallback) {
        var value = null == object ? void 0 : object[property];
        return void 0 === value && (value = fallback), _.isFunction(value) ? value.call(object) : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
    }, _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/, escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, escaper = /\\|'|\r|\n|\u2028|\u2029/g, escapeChar = function(match) {
        return "\\" + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
        !settings && oldSettings && (settings = oldSettings), settings = _.defaults({}, settings, _.templateSettings);
        var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g"), index = 0, source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            return source += text.slice(index, offset).replace(escaper, escapeChar), index = offset + match.length, 
            escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), 
            match;
        }), source += "';\n", settings.variable || (source = "with(obj||{}){\n" + source + "}\n"), 
        source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
            var render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
            throw e.source = source, e;
        }
        var template = function(data) {
            return render.call(this, data, _);
        }, argument = settings.variable || "obj";
        return template.source = "function(" + argument + "){\n" + source + "}", template;
    }, _.chain = function(obj) {
        var instance = _(obj);
        return instance._chain = !0, instance;
    };
    var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                return push.apply(args, arguments), result(this, func.apply(_, args));
            };
        });
    }, _.mixin(_), _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            return method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0], 
            result(this, obj);
        };
    }), _.each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result(this, method.apply(this._wrapped, arguments));
        };
    }), _.prototype.value = function() {
        return this._wrapped;
    }, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function() {
        return "" + this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return _;
    });
}.call(this), function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function() {
            var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments;
            for (message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                return index + 2 < templateArgs.length ? toDebugString(templateArgs[index + 2]) : match;
            }), message = message + "\nhttp://errors.angularjs.org/1.3.3/" + (module ? module + "/" : "") + code, 
            i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            return new ErrorConstructor(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = obj.length;
        return obj.nodeType === NODE_TYPE_ELEMENT && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; length > key; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort();
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function extend(dst) {
        for (var h = dst.$$hashKey, i = 1, ii = arguments.length; ii > i; i++) {
            var obj = arguments[i];
            if (obj) for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                var key = keys[j];
                dst[key] = obj[key];
            }
        }
        return setHashKey(dst, h), dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0].nodeName);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (stackSource = stackSource || [], stackDest = stackDest || [], isObject(source)) {
                var index = stackSource.indexOf(source);
                if (-1 !== index) return stackDest[index];
                stackSource.push(source), stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) result = copy(source[i], null, stackSource, stackDest), 
                isObject(source[i]) && (stackSource.push(source[i]), stackDest.push(result)), destination.push(result);
            } else {
                var h = destination.$$hashKey;
                isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                    delete destination[key];
                });
                for (var key in source) source.hasOwnProperty(key) && (result = copy(source[key], null, stackSource, stackDest), 
                isObject(source[key]) && (stackSource.push(source[key]), stackDest.push(result)), 
                destination[key] = result);
                setHashKey(destination, h);
            }
        } else if (destination = source, source) if (isArray(source)) destination = copy(source, [], stackSource, stackDest); else if (isDate(source)) destination = new Date(source.getTime()); else if (isRegExp(source)) destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), 
        destination.lastIndex = source.lastIndex; else if (isObject(source)) {
            var emptyObject = Object.create(Object.getPrototypeOf(source));
            destination = copy(source, emptyObject, stackSource, stackDest);
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key]);
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
                keySet = {};
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="), key = tryDecodeURIComponent(key_value[0]), 
            isDefined(key))) {
                var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val;
            }
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (element = jqLite(element), i = 0; ii > i; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, 
        isString(attr = element.attr(attr))) return attr;
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"), 
        bootstrap(appElement, module ? [ module ] : [], config));
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {
            strictDi: !1
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        void (angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        return angular.element(rootElement).injector().get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        var originalCleanData;
        bindJQueryFired || (jQuery = window.jQuery, jQuery && jQuery.fn.on ? (jqLite = jQuery, 
        extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
        }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function(elems) {
            var events;
            if (skipDestroyOnNextJQueryCleanData) skipDestroyOnNextJQueryCleanData = !1; else for (var elem, i = 0; null != (elem = elems[i]); i++) events = jQuery._data(elem, "events"), 
            events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
            originalCleanData(elems);
        }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0);
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0], endNode = nodes[nodes.length - 1], blockNodes = [ node ];
        do {
            if (node = node.nextSibling, !node) break;
            blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
    }
    function createMap() {
        return Object.create(null);
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "<<already seen>>";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj;
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        }), angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll) for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++) jqLiteRemoveData(descendants[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) if (type) forEach(type.split(" "), function(type) {
            if (isDefined(fn)) {
                var listenerFns = events[type];
                if (arrayRemove(listenerFns || [], fn), listenerFns && listenerFns.length > 0) return;
            }
            removeEventListenerFn(element, type, handle), delete events[type];
        }); else for (type in events) "$destroy" !== type && removeEventListenerFn(element, type, handle), 
        delete events[type];
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[key] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[key];
                extend(data, key);
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; length > i; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if ((value = jqLite.data(element, names[i])) !== undefined) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return ("INPUT" === nodeName || "TEXTAREA" === nodeName) && ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return event.immediatePropagationStopped === !0;
                }, eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++) event.isImmediatePropagationStopped() || eventFns[i].call(element, event);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), 
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this, undefined, name);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName);
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var length, i, key, args = [], $inject = annotate(fn, strictDi, serviceName);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance, returnedValue, Constructor = function() {};
                return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype, 
                instance = new Constructor(), returnedValue = invoke(Type, instance, locals, serviceName), 
                isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider, undefined, servicename);
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    return "a" === nodeName_(element) ? (result = element, !0) : void 0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll() {
                var elm, hash = $location.hash();
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, !1);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function startPoller(interval, setTimeout) {
            !function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                }), pollTimeout = setTimeout(check, interval);
            }();
        }
        function cacheStateAndFireUrlChange() {
            cacheState(), fireUrlChange();
        }
        function cacheState() {
            cachedState = window.history.state, cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState;
        }
        function fireUrlChange() {
            (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            }), 0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var pollTimeout, pollFns = [];
        self.addPollFn = function(fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), 
            fn;
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState(), lastHistoryState = cachedState, self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (reloadLocation = url), 
                replace ? location.replace(url) : location.href = url) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState(), lastHistoryState = cachedState), self;
            }
            return reloadLocation || location.href.replace(/%27/g, "'");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {}, lastCookieString = "", cookiePath = self.baseHref();
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (!name) {
                if (rawDocument.cookie !== lastCookieString) for (lastCookieString = rawDocument.cookie, 
                cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
                index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
                lastCookies[name] === undefined && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies;
            }
            value === undefined ? rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1, 
            cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"));
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!isUndefined(value)) return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                        value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        delete data[key], size--;
                    },
                    removeAll: function() {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = {};
            return forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                };
            }), bindings;
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), 
            hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = directive.require || directive.controller && directive.name, 
                        directive.restrict = directive.restrict || "EA", isObject(directive.scope) && (directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name)), 
                        directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
                    node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) && ($compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0]);
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope"), options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && node.toString().match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; ii > i; ) node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
                        (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = snake_case(ngAttrName.substr(6), "-"));
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        directiveIsMultiElement(directiveNName) && ngAttrName === directiveNName + "Start" && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if (className = node.className, isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                    } catch (e) {}
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                        node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, match, retrievalMethod = "data", optional = !1, $searchElement = $element;
                    if (isString(require)) {
                        if (match = require.match(REQUIRE_PREFIX_REGEXP), require = require.substring(match[0].length), 
                        match[3] && (match[1] ? match[3] = null : match[1] = match[3]), "^" === match[1] ? retrievalMethod = "inheritedData" : "^^" === match[1] && (retrievalMethod = "inheritedData", 
                        $searchElement = $element.parent()), "?" === match[2] && (optional = !0), value = null, 
                        elementControllers && "data" === retrievalMethod && (value = elementControllers[require]) && (value = value.instance), 
                        value = value || $searchElement[retrievalMethod]("$" + require + "Controller"), 
                        !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        return value || null;
                    }
                    return isArray(require) && (value = [], forEach(require, function(require) {
                        value.push(getControllers(directiveName, require, $element, elementControllers));
                    })), value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        return isScope(scope) || (futureParentElement = cloneAttachFn, cloneAttachFn = scope, 
                        scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), newIsolateScopeDirective && (isolateScope = scope.$new(!0)), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn), 
                    controllerDirectives && (controllers = {}, elementControllers = {}, forEach(controllerDirectives, function(directive) {
                        var controllerInstance, locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        };
                        controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), 
                        controllerInstance = $controller(controller, locals, !0, directive.controllerAs), 
                        elementControllers[directive.name] = controllerInstance, hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance.instance), 
                        controllers[directive.name] = controllerInstance;
                    })), newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                        compile.$$addScopeClass($element, !0);
                        var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name], isolateBindingContext = isolateScope;
                        isolateScopeController && isolateScopeController.identifier && newIsolateScopeDirective.bindToController === !0 && (isolateBindingContext = isolateScopeController.instance), 
                        forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                            switch (mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateBindingContext[scopeName] = value;
                                }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope));
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) return;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                                    return a === b || a !== a && b !== b;
                                }, parentSet = parentGet.assign || function() {
                                    throw lastValue = isolateBindingContext[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                }, lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                var parentValueWatch = function(parentValue) {
                                    return compare(parentValue, isolateBindingContext[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateBindingContext[scopeName]) : isolateBindingContext[scopeName] = parentValue), 
                                    lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = !0;
                                var unwatch;
                                unwatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                                isolateScope.$on("$destroy", unwatch);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]), isolateBindingContext[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                            }
                        });
                    }
                    for (controllers && (forEach(controllers, function(controller) {
                        controller();
                    }), controllers = null), i = 0, ii = preLinkFns.length; ii > i; i++) linkFn = preLinkFns[i], 
                    invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                }
                previousCompileContext = previousCompileContext || {};
                for (var newScopeDirective, controllers, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
                    controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
                    childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
                    assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective, nodeLinkFn.templateOnThisElement = hasTemplate, 
                nodeLinkFn.transclude = childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: !0
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                    directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), tDirectives.push(directive), match = directive);
                } catch (e) {
                    $exceptionHandler(e);
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
                    dstAttr[key] = srcAttr[key]);
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest($sce.getTrustedResourceUrl(templateUrl)).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                        }
                    }
                    linkQueue = null;
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? (linkQueue.push(scope), linkQueue.push(node), 
                    linkQueue.push(rootElement), linkQueue.push(childBoundTranscludeFn)) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0;
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var interpolateFn = $interpolate(value, !0);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = {});
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    attr[name] && (interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name), ALL_OR_NOTHING_ATTRS[name] || allOrNothing), 
                                    interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    })));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove), jqLite(newNode).data(jqLite(firstElementToRemove).data()), 
                jQuery ? (skipDestroyOnNextJQueryCleanData = !0, jQuery.cleanData([ firstElementToRemove ])) : delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; l > i; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], 
                    attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), 
                    "a" === nodeName && "href" === key || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        !listeners.$$inter && attrs.hasOwnProperty(key) && fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile;
        } ];
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            node.nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.allowGlobals = function() {
            globals = !0;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression) && (match = expression.match(CNTRL_REG), 
                constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : undefined), 
                assertArgFn(expression, constructor, !0)), later) {
                    var Constructor = function() {};
                    return Constructor.prototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype, 
                    instance = new Constructor(), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                    extend(function() {
                        return $injector.invoke(expression, instance, locals, constructor), instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function() {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            data = data.replace(JSON_PROTECTION_PREFIX, "");
            var contentType = headers("Content-Type");
            (contentType && 0 === contentType.indexOf(APPLICATION_JSON) && data.trim() || JSON_START.test(data) && JSON_END.test(data)) && (data = fromJson(data));
        }
        return data;
    }
    function parseHeaders(headers) {
        var key, val, i, parsed = {};
        return headers ? (forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), 
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }), parsed) : parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            return headersObj || (headersObj = parseHeaders(headers)), name ? headersObj[lowercase(name)] || null : headersObj;
        };
    }
    function transformData(data, headers, fns) {
        return isFunction(fns) ? fns(data, headers) : (forEach(fns, function(fn) {
            data = fn(data, headers);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = response.data ? transformData(response.data, response.headers, config.transformResponse) : response.data, 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function mergeHeaders(config) {
                    function execHeaders(headers) {
                        var headerContent;
                        forEach(headers, function(headerFn, header) {
                            isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent : delete headers[header]);
                        });
                    }
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return execHeaders(reqHeaders), reqHeaders;
                }
                var config = {
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, headers = mergeHeaders(requestConfig);
                extend(config, requestConfig), config.headers = headers, config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData, headers).then(transformResponse, transformResponse);
                }, chain = [ serverRequest, undefined ], promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
                }); chain.length; ) {
                    var thenFn = chain.shift(), rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                return promise.success = function(fn) {
                    return promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise.error = function(fn) {
                    return promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise;
            }
            function createShortMethods() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData, reqHeaders) {
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, url = buildUrl(config.url, config.params);
                if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache) if (cachedResp = cache.get(url), isDefined(cachedResp)) {
                    if (isPromiseLike(cachedResp)) return cachedResp.then(removePendingReq, removePendingReq), 
                    cachedResp;
                    isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK");
                } else cache.put(url, promise);
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) || (value = [ value ]), 
                    forEach(value, function(v) {
                        isObject(v) && (v = isDate(v) ? v.toISOString() : toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    }));
                }), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")), 
                url;
            }
            var defaultCache = $cacheFactory("$http"), reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function createXhr() {
        return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, callback(status, response, headersString, statusText), 
                $browser.$$completeOutstandingRequest(noop);
            }
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr();
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, withCredentials && (xhr.withCredentials = !0), 
                responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(post || null);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                }
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                    if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, 
                    expressionPositions.push(concat.length), concat.push("");
                }
                if (trustedContext && concat.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; ii > i; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    }, getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    }, stringify = function(value) {
                        if (null == value) return "";
                        switch (typeof value) {
                          case "string":
                            break;

                          case "number":
                            value = "" + value;
                            break;

                          default:
                            value = toJson(value);
                        }
                        return value;
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;ii > i; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr);
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            }, objectEquality);
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
                    clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
                $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
                !0) : !1;
            }, interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    return 1 === num ? "one" : "other";
                }
            };
        };
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index);
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, 
            rewrittenUrl = (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url), withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
            if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
            parseAppUrl(withoutHashUrl, this), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), 
            this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$parseLinkUrl = function(url) {
            return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) : !1;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            $location = new LocationMode(appBase, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && 2 != event.which) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                    isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                    $location.absUrl() != $browser.url() && ($rootScope.$apply(), window.angular["ff-684208-preventDefault"] = !0));
                }
            }), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                $rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), $rootScope.$$phase || $rootScope.$digest();
            }), $rootScope.$watch(function() {
                var oldUrl = $browser.url(), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== $location.absUrl() || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                    afterLocationChange(oldUrl, oldState)));
                })), $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.window === obj) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
    }
    function isConstant(exp) {
        return exp.constant;
    }
    function setter(obj, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp);
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = ensureSafeObject(obj[key], fullExp);
            propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj;
        }
        return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj[key], fullExp), 
        obj[key] = setValue, setValue;
    }
    function isPossiblyDangerousMemberName(name) {
        return "constructor" == name;
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), ensureSafeMemberName(key2, fullExp), 
        ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp);
        var eso = function(o) {
            return ensureSafeObject(o, fullExp);
        }, eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity, eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity, eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity, eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity, eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = eso0(pathVal[key0]), key1 ? null == pathVal ? undefined : (pathVal = eso1(pathVal[key1]), 
            key2 ? null == pathVal ? undefined : (pathVal = eso2(pathVal[key2]), key3 ? null == pathVal ? undefined : (pathVal = eso3(pathVal[key3]), 
            key4 ? null == pathVal ? undefined : pathVal = eso4(pathVal[key4]) : pathVal) : pathVal) : pathVal) : pathVal);
        };
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function(s, l) {
            return fn(s, l, ensureSafeObject, fullExpression);
        };
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks, getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault, fn = getterFnCache[path];
        if (fn) return fn;
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks) : function(scope, locals) {
            var val, i = 0;
            do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals), 
            locals = undefined, scope = val; while (pathKeysLength > i);
            return val;
        }; else {
            var code = "";
            expensiveChecks && (code += "s = eso(s, fe);\nl = eso(l, fe);\n");
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                (expensiveChecks || isPossiblyDangerousMemberName(key)) && (lookupJs = "eso(" + lookupJs + ", fe)", 
                needsEnsureSafeObject = !0), code += "if(s == null) return undefined;\ns=" + lookupJs + ";\n";
            }), code += "return s;";
            var evaledFnGetter = new Function("s", "l", "eso", "fe", code);
            evaledFnGetter.toString = valueFn(code), needsEnsureSafeObject && (evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp)), 
            fn = evaledFnGetter;
        }
        return fn.sharedGetter = !0, fn.assign = function(self, value) {
            return setter(self, path, value, path);
        }, getterFnCache[path] = fn, fn;
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap(), cacheExpensive = createMap();
        this.$get = [ "$filter", "$sniffer", function($filter, $sniffer) {
            function wrapSharedExpression(exp) {
                var wrapped = exp;
                return exp.sharedGetter && (wrapped = function(self, locals) {
                    return exp(self, locals);
                }, wrapped.literal = exp.literal, wrapped.constant = exp.constant, wrapped.assign = exp.assign), 
                wrapped;
            }
            function collectExpressionInputs(inputs, list) {
                for (var i = 0, ii = inputs.length; ii > i; i++) {
                    var input = inputs[i];
                    input.constant || (input.inputs ? collectExpressionInputs(input.inputs, list) : -1 === list.indexOf(input) && list.push(input));
                }
                return list;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), 
                "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var lastResult, inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                if (1 === inputExpressions.length) {
                    var oldInputValue = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValue) || (lastResult = parsedExpression(scope), 
                        oldInputValue = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality);
                }
                for (var oldInputValueOfValues = [], i = 0, ii = inputExpressions.length; ii > i; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope)), lastResult;
                }, listener, objectEquality);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.apply(this, arguments), isDefined(value) && scope.$$postDigest(function() {
                        isDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1);
                    }), allDefined;
                }
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.call(this, value, old, scope), 
                    isAllDefined(value) && scope.$$postDigest(function() {
                        isAllDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function() {
                    isFunction(listener) && listener.apply(this, arguments), unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    return interceptorFn(value, scope, locals);
                } : function(scope, locals) {
                    var value = parsedExpression(scope, locals), result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, 
                fn.inputs = [ parsedExpression ]), fn;
            }
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: !1
            }, $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: !0
            };
            return function(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    cacheKey = exp = exp.trim();
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    if (parsedExpression = cache[cacheKey], !parsedExpression) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? (parsedExpression = wrapSharedExpression(parsedExpression), 
                        parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate) : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        function callOnce(self, resolveFn, rejectFn) {
            function wrap(fn) {
                return function(value) {
                    called || (called = !0, fn.call(self, value));
                };
            }
            var called = !1;
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = undefined;
            for (var i = 0, ii = pending.length; ii > i; ++i) {
                promise = pending[i][0], fn = pending[i][state.status];
                try {
                    isFunction(fn) ? promise.resolve(fn(state.value)) : 1 === state.status ? promise.resolve(state.value) : promise.reject(state.value);
                } catch (e) {
                    promise.reject(e), exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !state.processScheduled && state.pending && (state.processScheduled = !0, nextTick(function() {
                processQueue(state);
            }));
        }
        function Deferred() {
            this.promise = new Promise(), this.resolve = simpleBind(this, this.resolve), this.reject = simpleBind(this, this.reject), 
            this.notify = simpleBind(this, this.notify);
        }
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason);
                });
            }), 0 === counter && deferred.resolve(results), deferred.promise;
        }
        var $qMinErr = minErr("$q", TypeError), defer = function() {
            return new Deferred();
        };
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, !0, callback);
                }, function(error) {
                    return handleCallback(error, !1, callback);
                }, progressBack);
            }
        }, Deferred.prototype = {
            resolve: function(val) {
                this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val));
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    (isObject(val) || isFunction(val)) && (then = val && val.then), isFunction(then) ? (this.promise.$$state.status = -1, 
                    then.call(val, fns[0], fns[1], this.notify)) : (this.promise.$$state.value = val, 
                    this.promise.$$state.status = 1, scheduleProcessQueue(this.promise.$$state));
                } catch (e) {
                    fns[1](e), exceptionHandler(e);
                }
            },
            reject: function(reason) {
                this.promise.$$state.status || this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason, this.promise.$$state.status = 2, scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                    for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            result.notify(isFunction(callback) ? callback(progress) : progress);
                        } catch (e) {
                            exceptionHandler(e);
                        }
                    }
                });
            }
        };
        var reject = function(reason) {
            var result = new Deferred();
            return result.reject(reason), result.promise;
        }, makePromise = function(value, resolved) {
            var result = new Deferred();
            return resolved ? result.resolve(value) : result.reject(value), result.promise;
        }, handleCallback = function(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return makePromise(e, !1);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return makePromise(value, isResolved);
            }, function(error) {
                return makePromise(error, !1);
            }) : makePromise(value, isResolved);
        }, when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            return result.resolve(value), result.promise.then(callback, errback, progressBack);
        }, $Q = function Q(resolver) {
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            if (!(this instanceof Q)) return new Q(resolver);
            var deferred = new Deferred();
            return resolver(resolveFn, rejectFn), deferred.promise;
        };
        return $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.all = all, $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, 
                this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    function destroyChild() {
                        child.$$destroyed = !0;
                    }
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = function() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                        this.$$listeners = {}, this.$$listenerCount = {}, this.$id = nextUid(), this.$$ChildScope = null;
                    }, this.$$ChildScope.prototype = this), child = new this.$$ChildScope()), child.$parent = parent, 
                    child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, 
                    parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, (isolate || parent != this) && child.$on("$destroy", destroyChild), 
                    child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, listener, objectEquality, get);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = []), 
                    array.unshift(watcher), function() {
                        arrayRemove(array, watcher), lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; newLength > i; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, 
                                bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, 
                                oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) newValue.hasOwnProperty(key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        for (dirty = !1, current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
                                if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; ) try {
                        postDigestQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        if (this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope) {
                            for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
                            this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                            this.$on = this.$watch = this.$watchGroup = function() {
                                return noop;
                            }, this.$$listeners = {}, this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                        }
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        expression: expr
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        return beginPhase("$apply"), this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event.currentScope = null, event;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function() {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && 8 > msie) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
                    vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                    break;
                }
                vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
                !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), 
                animations = isString(document.body.style.webkitAnimation));
            }
            return {
                history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                hasEvent: function(event) {
                    if ("input" == event && 9 == msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", function($templateCache, $http, $q) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError() {
                    if (self.totalPendingRequests--, !ignoreRequestError) throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                    return $q.reject();
                }
                var self = handleRequestFn;
                self.totalPendingRequests++;
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    var original = transformResponse;
                    transformResponse = [];
                    for (var i = 0; i < original.length; ++i) {
                        var transformer = original[i];
                        transformer !== defaultHttpResponseTransform && transformResponse.push(transformer);
                    }
                } else transformResponse === defaultHttpResponseTransform && (transformResponse = null);
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions).then(function(response) {
                    var html = response.data;
                    return self.totalPendingRequests--, $templateCache.put(tpl, html), html;
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                            matcher.test(bindingName) && matches.push(binding);
                        } else -1 != bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                var timeoutId, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
                delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var comparatorType = typeof comparator, predicates = [];
            predicates.check = function(value, index) {
                for (var j = 0; j < predicates.length; j++) if (!predicates[j](value, index)) return !1;
                return !0;
            }, "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ? function(obj, text) {
                return angular.equals(obj, text);
            } : function(obj, text) {
                if (obj && text && "object" == typeof obj && "object" == typeof text) {
                    for (var objKey in obj) if ("$" !== objKey.charAt(0) && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) return !0;
                    return !1;
                }
                return text = ("" + text).toLowerCase(), ("" + obj).toLowerCase().indexOf(text) > -1;
            });
            var search = function(obj, text) {
                if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
                switch (typeof obj) {
                  case "boolean":
                  case "number":
                  case "string":
                    return comparator(obj, text);

                  case "object":
                    switch (typeof text) {
                      case "object":
                        return comparator(obj, text);

                      default:
                        for (var objKey in obj) if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0;
                    }
                    return !1;

                  case "array":
                    for (var i = 0; i < obj.length; i++) if (search(obj[i], text)) return !0;
                    return !1;

                  default:
                    return !1;
                }
            };
            switch (typeof expression) {
              case "boolean":
              case "number":
              case "string":
                expression = {
                    $: expression
                };

              case "object":
                for (var key in expression) !function(path) {
                    "undefined" != typeof expression[path] && predicates.push(function(value) {
                        return search("$" == path ? value : value && value[path], expression[path]);
                    });
                }(key);
                break;

              case "function":
                predicates.push(expression);
                break;

              default:
                return array;
            }
            for (var filtered = [], j = 0; j < array.length; j++) {
                var value = array[j];
                predicates.check(value, j) && filtered.push(value);
            }
            return filtered;
        };
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = 2), 
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [], hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? (numStr = "0", number = 0) : (formatedText = numStr, 
            hasExponent = !0);
        }
        if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize)); else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize), 
            0 === number && (isNegative = !1);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (;fraction.length < fractionSize; ) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
        }
        return parts.push(isNegative ? pattern.negPre : pattern.posPre), parts.push(formatedText), 
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf), parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
            padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset(), paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), 
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour, m = int(match[5] || 0) - tzMin, s = int(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            return timezone && "UTC" === timezone && (date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + date.getTimezoneOffset())), 
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object) {
            return toJson(object, !0);
        };
    }
    function limitToFilter() {
        return function(input, limit) {
            if (isNumber(input) && (input = input.toString()), !isArray(input) && !isString(input)) return input;
            if (limit = 1/0 === Math.abs(Number(limit)) ? Number(limit) : int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length) : "";
            var i, n, out = [];
            for (limit > input.length ? limit = input.length : limit < -input.length && (limit = -input.length), 
            limit > 0 ? (i = 0, n = limit) : (i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
            return out;
        };
    }
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function compare(v1, v2) {
                var t1 = typeof v1, t2 = typeof v2;
                return t1 == t2 ? (isDate(v1) && isDate(v2) && (v1 = v1.valueOf(), v2 = v2.valueOf()), 
                "string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1;
            }
            return isArrayLike(array) ? (sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ], 
            0 === sortPredicate.length && (sortPredicate = [ "+" ]), sortPredicate = sortPredicate.map(function(predicate) {
                var descending = !1, get = predicate || identity;
                if (isString(predicate)) {
                    if (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), 
                    predicate = predicate.substring(1)), "" === predicate) return reverseComparator(function(a, b) {
                        return compare(a, b);
                    }, descending);
                    if (get = $parse(predicate), get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key]);
                        }, descending);
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            }), slice.call(array).sort(reverseComparator(comparator, reverseOrder))) : array;
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [], parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {}, form.$$success = {}, form.$pending = undefined, form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope), 
        form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, form.$submitted = !1, 
        parentForm.$addControl(form), form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        }, form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        }, form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control);
        }, form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            form[oldName] === control && delete form[oldName], form[newName] = control, control.$name = newName;
        }, form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name], 
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            }), forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            }), arrayRemove(controls, control);
        }, addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, control) {
                var list = object[property];
                if (list) {
                    var index = list.indexOf(control);
                    -1 === index && list.push(control);
                } else object[property] = [ control ];
            },
            unset: function(object, property, control) {
                var list = object[property];
                list && (arrayRemove(list, control), 0 === list.length && delete object[property]);
            },
            parentForm: parentForm,
            $animate: $animate
        }), form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
            form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty();
        }, form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), 
            form.$dirty = !1, form.$pristine = !0, form.$submitted = !1, forEach(controls, function(control) {
                control.$setPristine();
            });
        }, form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        }, form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS), form.$submitted = !0, parentForm.$setSubmitted();
        };
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var placeholder = element[0].placeholder, noevent = {}, type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var listener = function(ev) {
            if (!composing) {
                var value = element.val(), event = ev && ev.type;
                if (msie && "input" === (ev || noevent).type && element[0].placeholder !== placeholder) return void (placeholder = element[0].placeholder);
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var timeout, deferListener = function(ev) {
                timeout || (timeout = $browser.defer(function() {
                    listener(ev), timeout = null;
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event);
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$modelValue) ? "" : ctrl.$viewValue);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return 0/0;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) return parts.shift(), map = date ? {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, forEach(parts, function(part, index) {
                    index < mapping.length && (map[mapping[index]] = +part);
                }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
            }
            return 0/0;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined;
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return "UTC" === timezone && parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset()), 
                    parsedDate;
                }
                return undefined;
            }), ctrl.$formatters.push(function(value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isDate(value)) throw $ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                    if (previousDate = value, previousDate && "UTC" === timezone) {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset);
                    }
                    return $filter("date")(value, format, timezone);
                }
                return previousDate = null, "";
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return ctrl.$isEmpty(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return ctrl.$isEmpty(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            ctrl.$isEmpty = function(value) {
                return !value || value.getTime && value.getTime() !== value.getTime();
            };
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
        });
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), 
        ctrl.$$parserName = "number", ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : undefined;
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw $ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        }), attr.min || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            }, attr.$observe("min", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), minVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
        if (attr.max || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value;
            }, attr.$observe("max", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), maxVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "url", ctrl.$validators.url = function(value) {
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "email", ctrl.$validators.email = function(value) {
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw minErr("ngModel")("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value !== trueValue;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function addSetValidityMethod(context) {
        function setValidity(validationErrorKey, state, options) {
            state === undefined ? createAndSet("$pending", validationErrorKey, options) : unsetAndCleanup("$pending", validationErrorKey, options), 
            isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, options), set(ctrl.$$success, validationErrorKey, options)) : (set(ctrl.$error, validationErrorKey, options), 
            unset(ctrl.$$success, validationErrorKey, options)) : (unset(ctrl.$error, validationErrorKey, options), 
            unset(ctrl.$$success, validationErrorKey, options)), ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0), 
            ctrl.$valid = ctrl.$invalid = undefined, toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1), 
            ctrl.$valid = isObjectEmpty(ctrl.$error), ctrl.$invalid = !ctrl.$valid, toggleValidationCss("", ctrl.$valid));
            var combinedState;
            combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? undefined : ctrl.$error[validationErrorKey] ? !1 : ctrl.$$success[validationErrorKey] ? !0 : null, 
            toggleValidationCss(validationErrorKey, combinedState), parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, options) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, options);
        }
        function unsetAndCleanup(name, value, options) {
            ctrl[name] && unset(ctrl[name], value, options), isObjectEmpty(ctrl[name]) && (ctrl[name] = undefined);
        }
        function cachedToggleClass(className, switchValue) {
            switchValue && !classCache[className] ? ($animate.addClass($element, className), 
            classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className), 
            classCache[className] = !1);
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === !1);
        }
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, parentForm = context.parentForm, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)), 
        ctrl.$setValidity = setValidity;
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) return !1;
        return !0;
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, [ "$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) return classVal;
                if (isString(classVal)) return classVal.split(" ");
                if (isObject(classVal)) {
                    var classes = [];
                    return forEach(classVal, function(v, k) {
                        v && (classes = classes.concat(k.split(" ")));
                    }), classes;
                }
                return classVal;
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {}, classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1), toRemove = digestClassCounts(toRemove, -1), 
                        toAdd && toAdd.length && $animate.addClass(element, toAdd), toRemove && toRemove.length && $animate.removeClass(element, toRemove);
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === !0 || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses);
                                }
                            } else addClasses(newClasses);
                        }
                        oldVal = shallowCopy(newVal);
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function() {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    }), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes);
                        }
                    });
                }
            };
        } ];
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = document.documentMode, noop.$inject = [], identity.$inject = [];
    var skipDestroyOnNextJQueryCleanData, isArray = Array.isArray, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        if (isDefined(csp.isActive_)) return csp.isActive_;
        var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
        if (!active) try {
            new Function("");
        } catch (e) {
            active = !0;
        }
        return csp.isActive_ = active;
    }, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.3.3",
        major: 1,
        minor: 3,
        dot: 3,
        codeName: "undersea-arithmetic"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, !1);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, !1);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0, fn());
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), 
            JQLite(window).on("load", trigger));
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = camelCase(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, 
                element.removeAttribute(lowercasedName));
            } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return null === ret ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), 0 === result.length ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length; i--; ) {
                    type = types[i];
                    var eventFns = events[type];
                    eventFns || (events[type] = [], "mouseenter" === type || "mouseleave" === type ? jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                        var target = this, related = event.relatedTarget;
                        (!related || related !== target && !target.contains(related)) && handle(event, type);
                    }) : "$destroy" !== type && addEventListenerFn(element, type, handle), eventFns = events[type]), 
                    eventFns.push(fn);
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; ii > i; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling), index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return this.defaultPrevented === !0;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return this.immediatePropagationStopped === !0;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    }), HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {}, this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null), 
            this.$$classNameFilter;
        }, this.$get = [ "$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                return defer.promise.$$cancelFn = function() {
                    cancelFn && cancelFn();
                }, $rootScope.$$postDigest(function() {
                    cancelFn = fn(function() {
                        defer.resolve();
                    });
                }), defer.promise;
            }
            function resolveElementClasses(element, classes) {
                var toAdd = [], toRemove = [], hasClasses = createMap();
                return forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = !0;
                }), forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    status === !1 && hasClass ? toRemove.push(className) : status !== !0 || hasClass || toAdd.push(className);
                }), toAdd.length + toRemove.length > 0 && [ toAdd.length ? toAdd : null, toRemove.length ? toRemove : null ];
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; ii > i; ++i) {
                    var className = classes[i];
                    cache[className] = op;
                }
            }
            function asyncPromise() {
                return currentDefer || (currentDefer = $$q.defer(), $$asyncCallback(function() {
                    currentDefer.resolve(), currentDefer = null;
                })), currentDefer.promise;
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles);
                }
            }
            var currentDefer;
            return {
                animate: function(element, from, to) {
                    return applyStyles(element, {
                        from: from,
                        to: to
                    }), asyncPromise();
                },
                enter: function(element, parent, after, options) {
                    return applyStyles(element, options), after ? after.after(element) : parent.prepend(element), 
                    asyncPromise();
                },
                leave: function(element) {
                    return element.remove(), asyncPromise();
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options);
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options);
                },
                $$addClassImmediately: function(element, className, options) {
                    return element = jqLite(element), className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    }), applyStyles(element, options), asyncPromise();
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options);
                },
                $$removeClassImmediately: function(element, className, options) {
                    return element = jqLite(element), className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    }), applyStyles(element, options), asyncPromise();
                },
                setClass: function(element, add, remove, options) {
                    var self = this, STORAGE_KEY = "$$animateClasses", createdCache = !1;
                    element = jqLite(element);
                    var cache = element.data(STORAGE_KEY);
                    cache ? options && cache.options && (cache.options = angular.extend(cache.options || {}, options)) : (cache = {
                        classes: {},
                        options: options
                    }, createdCache = !0);
                    var classes = cache.classes;
                    return add = isArray(add) ? add : add.split(" "), remove = isArray(remove) ? remove : remove.split(" "), 
                    cachedClassManipulation(classes, add, !0), cachedClassManipulation(classes, remove, !1), 
                    createdCache && (cache.promise = runAnimationPostDigest(function(done) {
                        var cache = element.data(STORAGE_KEY);
                        if (element.removeData(STORAGE_KEY), cache) {
                            var classes = resolveElementClasses(element, cache.classes);
                            classes && self.$$setClassImmediately(element, classes[0], classes[1], cache.options);
                        }
                        done();
                    }), element.data(STORAGE_KEY, cache)), cache.promise;
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    return add && this.$$addClassImmediately(element, add), remove && this.$$removeClassImmediately(element, remove), 
                    applyStyles(element, options), asyncPromise();
                },
                enabled: noop,
                cancel: noop
            };
        } ];
    } ], $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/, $interpolateMinErr = minErr("$interpolate"), PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), locationPrototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return match[1] && this.path(decodeURIComponent(match[1])), (match[2] || match[1]) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" == path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this;
        };
    });
    var $parseMinErr = minErr("$parse"), CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, CONSTANTS = createMap();
    forEach({
        "null": function() {
            return null;
        },
        "true": function() {
            return !0;
        },
        "false": function() {
            return !1;
        },
        undefined: function() {}
    }, function(constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = !0, 
        CONSTANTS[name] = constantGetter;
    }), CONSTANTS["this"] = function(self) {
        return self;
    }, CONSTANTS["this"].sharedGetter = !0;
    var OPERATORS = extend(createMap(), {
        "+": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        },
        "=": !0,
        "|": !0
    }), ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(ch)) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || " " === ch;
        },
        isIdent: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            for (var start = this.index; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (!this.isIdent(ch) && !this.isNumber(ch)) break;
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        sharedGetter: !0,
        constant: !0
    }), Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.statements();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value.literal = !!value.literal, value.constant = !!value.constant, value;
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next, context; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = this.functionCall(primary, context), 
            context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, 
            primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        unaryFn: function(op, right) {
            var fn = OPERATORS[op];
            return extend(function(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant,
                inputs: [ right ]
            });
        },
        binaryFn: function(left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant,
                inputs: !isBranching && [ left, right ]
            });
        },
        identifier: function() {
            for (var id = this.consume().text; this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "("); ) id += this.consume().text + this.consume().text;
            return CONSTANTS[id] || getterFn(id, this.options, this.text);
        },
        constant: function() {
            var value = this.consume().value;
            return extend(function() {
                return value;
            }, {
                constant: !0,
                literal: !0
            });
        },
        statements: function() {
            for (var statements = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), 
            !this.expect(";")) return 1 === statements.length ? statements[0] : function(self, locals) {
                for (var value, i = 0, ii = statements.length; ii > i; i++) value = statements[i](self, locals);
                return value;
            };
        },
        filterChain: function() {
            for (var token, left = this.expression(); token = this.expect("|"); ) left = this.filter(left);
            return left;
        },
        filter: function(inputFn) {
            var argsFn, args, fn = this.$filter(this.consume().text);
            if (this.peek(":")) for (argsFn = [], args = []; this.expect(":"); ) argsFn.push(this.expression());
            var inputs = [ inputFn ].concat(argsFn || []);
            return extend(function(self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    for (var i = argsFn.length; i--; ) args[i + 1] = argsFn[i](self, locals);
                    return fn.apply(undefined, args);
                }
                return fn(input);
            }, {
                constant: !fn.$stateful && inputs.every(isConstant),
                inputs: !fn.$stateful && inputs
            });
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var right, token, left = this.ternary();
            return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), 
            right = this.ternary(), extend(function(scope, locals) {
                return left.assign(scope, right(scope, locals), locals);
            }, {
                inputs: [ left, right ]
            })) : left;
        },
        ternary: function() {
            var middle, token, left = this.logicalOR();
            if ((token = this.expect("?")) && (middle = this.assignment(), this.consume(":"))) {
                var right = this.assignment();
                return extend(function(self, locals) {
                    return left(self, locals) ? middle(self, locals) : right(self, locals);
                }, {
                    constant: left.constant && middle.constant && right.constant
                });
            }
            return left;
        },
        logicalOR: function() {
            for (var token, left = this.logicalAND(); token = this.expect("||"); ) left = this.binaryFn(left, token.text, this.logicalAND(), !0);
            return left;
        },
        logicalAND: function() {
            var token, left = this.equality();
            return (token = this.expect("&&")) && (left = this.binaryFn(left, token.text, this.logicalAND(), !0)), 
            left;
        },
        equality: function() {
            var token, left = this.relational();
            return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.text, this.equality())), 
            left;
        },
        relational: function() {
            var token, left = this.additive();
            return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.text, this.relational())), 
            left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = this.binaryFn(left, token.text, this.multiplicative());
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = this.binaryFn(left, token.text, this.unary());
            return left;
        },
        unary: function() {
            var token;
            return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.text, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.text, this.unary()) : this.primary();
        },
        fieldAccess: function(object) {
            var expression = this.text, field = this.consume().text, getter = getterFn(field, this.options, expression);
            return extend(function(scope, locals, self) {
                return getter(self || object(scope, locals));
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    return o || object.assign(scope, o = {}), setter(o, field, value, expression);
                }
            });
        },
        objectIndex: function(obj) {
            var expression = this.text, indexFn = this.expression();
            return this.consume("]"), extend(function(self, locals) {
                var v, o = obj(self, locals), i = indexFn(self, locals);
                return ensureSafeMemberName(i, expression), o ? v = ensureSafeObject(o[i], expression) : undefined;
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), expression), o = ensureSafeObject(obj(self, locals), expression);
                    return o || obj.assign(self, o = {}), o[key] = value;
                }
            });
        },
        functionCall: function(fnGetter, contextGetter) {
            var argsFn = [];
            if (")" !== this.peekToken().text) do argsFn.push(this.expression()); while (this.expect(","));
            this.consume(")");
            var expressionText = this.text, args = argsFn.length ? [] : null;
            return function(scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : scope, fn = fnGetter(scope, locals, context) || noop;
                if (args) for (var i = argsFn.length; i--; ) args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                ensureSafeObject(context, expressionText), ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, expressionText);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elementFns.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), extend(function(self, locals) {
                for (var array = [], i = 0, ii = elementFns.length; ii > i; i++) array.push(elementFns[i](self, locals));
                return array;
            }, {
                literal: !0,
                constant: elementFns.every(isConstant),
                inputs: elementFns
            });
        },
        object: function() {
            var keys = [], valueFns = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                var token = this.consume();
                token.constant ? keys.push(token.value) : token.identifier ? keys.push(token.text) : this.throwError("invalid key", token), 
                this.consume(":"), valueFns.push(this.expression());
            } while (this.expect(","));
            return this.consume("}"), extend(function(self, locals) {
                for (var object = {}, i = 0, ii = valueFns.length; ii > i; i++) object[keys[i]] = valueFns[i](self, locals);
                return object;
            }, {
                literal: !0,
                constant: valueFns.every(isConstant),
                inputs: valueFns
            });
        }
    };
    var getterFnCacheDefault = createMap(), getterFnCacheExpensive = createMap(), objectValueOf = Object.prototype.valueOf, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, $compileMinErr = minErr("$compile"), urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href);
    $FilterProvider.$inject = [ "$provide" ], currencyFilter.$inject = [ "$locale" ], 
    numberFilter.$inject = [ "$locale" ];
    var DECIMAL_SEP = ".", DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1)
    }, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return attr.href || attr.xlinkHref || attr.name ? void 0 : function(scope, element) {
                var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                element.on("click", function(event) {
                    element.attr(href) || event.preventDefault();
                });
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: function(scope, element, attr) {
                        scope.$watch(attr[normalized], function(value) {
                            attr.$set(attrName, !!value);
                        });
                    }
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function(formElement) {
                    return formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS), {
                        pre: function(scope, formElement, attr, controller) {
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault ? event.preventDefault() : event.returnValue = !1;
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = controller.$$parentForm, alias = controller.$name;
                            alias && (setter(scope, alias, controller, alias), attr.$observe(attr.name ? "name" : "ngForm", function(newValue) {
                                alias !== newValue && (setter(scope, alias, undefined, alias), alias = newValue, 
                                setter(scope, alias, controller, alias), parentFormCtrl.$$renameControl(controller, alias));
                            })), formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller), alias && setter(scope, alias, undefined, alias), 
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/, $ngModelMinErr = new minErr("ngModel"), inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$validators = {}, 
        this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], 
        this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, 
        this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = undefined, 
        this.$name = $interpolate($attr.name || "", !1)($scope);
        var parsedNgModel = $parse($attr.ngModel), pendingDebounce = null, ctrl = this, ngModelGet = function() {
            var modelValue = parsedNgModel($scope);
            return ctrl.$options && ctrl.$options.getterSetter && isFunction(modelValue) && (modelValue = modelValue()), 
            modelValue;
        }, ngModelSet = function() {
            var getterSetter;
            ctrl.$options && ctrl.$options.getterSetter && isFunction(getterSetter = parsedNgModel($scope)) ? getterSetter(ctrl.$modelValue) : parsedNgModel.assign($scope, ctrl.$modelValue);
        };
        this.$$setOptions = function(options) {
            if (ctrl.$options = options, !(parsedNgModel.assign || options && options.getterSetter)) throw $ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        }, this.$render = noop, this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = !0;
            },
            unset: function(object, property) {
                delete object[property];
            },
            parentForm: parentForm,
            $animate: $animate
        }), this.$setPristine = function() {
            ctrl.$dirty = !1, ctrl.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
            $animate.addClass($element, PRISTINE_CLASS);
        }, this.$setUntouched = function() {
            ctrl.$touched = !1, ctrl.$untouched = !0, $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        }, this.$setTouched = function() {
            ctrl.$touched = !0, ctrl.$untouched = !1, $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        }, this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce), ctrl.$viewValue = ctrl.$$lastCommittedViewValue, 
            ctrl.$render();
        }, this.$validate = function() {
            isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) || this.$$parseAndValidate();
        }, this.$$runValidators = function(parseValid, modelValue, viewValue, doneCallback) {
            function processParseErrors(parseValid) {
                var errorKey = ctrl.$$parserName || "parse";
                if (parseValid === undefined) setValidity(errorKey, null); else if (setValidity(errorKey, parseValid), 
                !parseValid) return forEach(ctrl.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1;
                return !0;
            }
            function processSyncValidators() {
                var syncValidatorsValid = !0;
                return forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), syncValidatorsValid ? !0 : (forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }
            function processAsyncValidators() {
                var validatorPromises = [], allValid = !0;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, undefined), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function() {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? $q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }
            function setValidity(name, isValid) {
                localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === currentValidationRunId && doneCallback(allValid);
            }
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            return processParseErrors(parseValid) && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1);
        }, this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce), (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$lastCommittedViewValue = viewValue, 
            ctrl.$pristine && (ctrl.$dirty = !0, ctrl.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), 
            $animate.addClass($element, DIRTY_CLASS), parentForm.$setDirty()), this.$$parseAndValidate());
        }, this.$$parseAndValidate = function() {
            function writeToModelIfNeeded() {
                ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope();
            }
            var viewValue = ctrl.$$lastCommittedViewValue, modelValue = viewValue, parserValid = isUndefined(modelValue) ? undefined : !0;
            if (parserValid) for (var i = 0; i < ctrl.$parsers.length; i++) if (modelValue = ctrl.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                parserValid = !1;
                break;
            }
            isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet());
            var prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            allowInvalid && (ctrl.$modelValue = modelValue, writeToModelIfNeeded()), ctrl.$$runValidators(parserValid, modelValue, viewValue, function(allValid) {
                allowInvalid || (ctrl.$modelValue = allValid ? modelValue : undefined, writeToModelIfNeeded());
            });
        }, this.$$writeModelToScope = function() {
            ngModelSet(ctrl.$modelValue), forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        }, this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value, (!ctrl.$options || ctrl.$options.updateOnDefault) && ctrl.$$debounceViewValueCommit(trigger);
        }, this.$$debounceViewValueCommit = function(trigger) {
            var debounce, debounceDelay = 0, options = ctrl.$options;
            options && isDefined(options.debounce) && (debounce = options.debounce, isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce["default"]) && (debounceDelay = debounce["default"])), 
            $timeout.cancel(pendingDebounce), debounceDelay ? pendingDebounce = $timeout(function() {
                ctrl.$commitViewValue();
            }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function() {
                ctrl.$commitViewValue();
            });
        }, $scope.$watch(function() {
            var modelValue = ngModelGet();
            if (modelValue !== ctrl.$modelValue) {
                ctrl.$modelValue = modelValue;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, 
                ctrl.$render(), ctrl.$$runValidators(undefined, modelValue, viewValue, noop));
            }
            return modelValue;
        });
    } ], ngModelDirective = function() {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options), formCtrl.$addControl(modelCtrl), 
                        attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && formCtrl.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                        }), element.on("blur", function() {
                            modelCtrl.$touched || scope.$apply(function() {
                                modelCtrl.$setTouched();
                            });
                        });
                    }
                };
            }
        };
    }, ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(value) {
                    return !attr.required || !ctrl.$isEmpty(value);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || undefined, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(value) {
                        return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = 0;
                    attr.$observe("maxlength", function(value) {
                        maxlength = int(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(modelValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = int(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(modelValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    }, ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : undefined;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value);
                    });
                };
            }
        };
    }, ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = $scope.$eval($attrs.ngModelOptions), this.$options.updateOn !== undefined ? (this.$options.updateOnDefault = !1, 
                this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                    return that.$options.updateOnDefault = !0, " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(value) {
                    return (value || "").toString();
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ], ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, !0);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).then(function() {
                        previousElements = null;
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", "$sce", function($templateRequest, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                            previousElement = null;
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return /SVG/.test($element[0].toString()) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
                forEach(attr, function(expression, attributeName) {
                    isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]));
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
                }), scope.$watch(function() {
                    var value = parseFloat(scope.$eval(numberExp));
                    return isNaN(value) ? "" : (value in whens || (value = $locale.pluralCat(value - offset)), 
                    whensExpFns[value](scope));
                }, function(newVal) {
                    element.text(newVal);
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 === (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " "), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) collection.hasOwnProperty(itemKey) && "$" != itemKey.charAt(0) && collectionKeys.push(itemKey);
                            collectionKeys.sort();
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: undefined,
                                clone: undefined
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; length > index; index++) elementsToRemove[index][NG_REMOVED] = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode)), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, jqLite(previousNode)), 
                            previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; ii > i; ++i) $animate.cancel(previousLeaveAnimations[i]);
                    for (previousLeaveAnimations.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    }), scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], ngOptionsMinErr = minErr("ngOptions"), ngOptionsDirective = valueFn({
        restrict: "A",
        terminal: !0
    }), selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
                self.databound = $attrs.ngModel, self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_;
                }, self.addOption = function(value, element) {
                    assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), 
                    unknownOption.parent() && unknownOption.remove()), element && element[0].hasAttribute("selected") && (element[0].selected = !0);
                }, self.removeOption = function(value) {
                    this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value));
                }, self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), 
                    unknownOption.prop("selected", !0);
                }, self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                }, $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), 
                        selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue);
                    }, selectElement.on("change", function() {
                        scope.$apply(function() {
                            unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    }, scope.$watch(function() {
                        equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue), ctrl.$render());
                    }), selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                option.selected && array.push(option.value);
                            }), ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    function callExpression(exprFn, key, value) {
                        return locals[valueName] = value, keyName && (locals[keyName] = key), exprFn(scope, locals);
                    }
                    function selectionChanged() {
                        scope.$apply(function() {
                            var viewValue, collection = valuesFn(scope) || [];
                            if (multiple) viewValue = [], forEach(selectElement.val(), function(selectedKey) {
                                selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey, viewValue.push(getViewValue(selectedKey, collection[selectedKey]));
                            }); else {
                                var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                viewValue = getViewValue(selectedKey, collection[selectedKey]);
                            }
                            ctrl.$setViewValue(viewValue), render();
                        });
                    }
                    function getViewValue(key, value) {
                        if ("?" === key) return undefined;
                        if ("" === key) return null;
                        var viewValueFn = selectAsFn ? selectAsFn : valueFn;
                        return callExpression(viewValueFn, key, value);
                    }
                    function getLabels() {
                        var toDisplay, values = valuesFn(scope);
                        if (values && isArray(values)) {
                            toDisplay = new Array(values.length);
                            for (var i = 0, ii = values.length; ii > i; i++) toDisplay[i] = callExpression(displayFn, i, values[i]);
                            return toDisplay;
                        }
                        if (values) {
                            toDisplay = {};
                            for (var prop in values) values.hasOwnProperty(prop) && (toDisplay[prop] = callExpression(displayFn, prop, values[prop]));
                        }
                        return toDisplay;
                    }
                    function createIsSelectedFn(viewValue) {
                        var selectedSet;
                        if (multiple) if (trackFn && isArray(viewValue)) {
                            selectedSet = new HashMap([]);
                            for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++) selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), !0);
                        } else selectedSet = new HashMap(viewValue); else trackFn && (viewValue = callExpression(trackFn, null, viewValue));
                        return function(key, value) {
                            var compareValueFn;
                            return compareValueFn = trackFn ? trackFn : selectAsFn ? selectAsFn : valueFn, multiple ? isDefined(selectedSet.remove(callExpression(compareValueFn, key, value))) : viewValue === callExpression(compareValueFn, key, value);
                        };
                    }
                    function scheduleRendering() {
                        renderScheduled || (scope.$$postDigest(render), renderScheduled = !0);
                    }
                    function updateLabelMap(labelMap, label, added) {
                        labelMap[label] = labelMap[label] || 0, labelMap[label] += added ? 1 : -1;
                    }
                    function render() {
                        renderScheduled = !1;
                        var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, value, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionId, optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, labelMap = {}, isSelected = createIsSelectedFn(viewValue), anySelected = !1;
                        for (trackKeysCache = {}, index = 0; length = keys.length, length > index; index++) key = index, 
                        keyName && (key = keys[index], "$" === key.charAt(0)) || (value = values[key], optionGroupName = callExpression(groupByFn, key, value) || "", 
                        (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], 
                        optionGroupNames.push(optionGroupName)), selected = isSelected(key, value), anySelected = anySelected || selected, 
                        label = callExpression(displayFn, key, value), label = isDefined(label) ? label : "", 
                        optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index, trackFn && (trackKeysCache[optionId] = key), 
                        optionGroup.push({
                            id: optionId,
                            label: label,
                            selected: selected
                        }));
                        for (multiple || (nullOption || null === viewValue ? optionGroups[""].unshift({
                            id: "",
                            label: "",
                            selected: !anySelected
                        }) : anySelected || optionGroups[""].unshift({
                            id: "?",
                            label: "",
                            selected: !0
                        })), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                            for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], 
                            optionGroupsCache.length <= groupIndex ? (existingParent = {
                                element: optGroupTemplate.clone().attr("label", optionGroupName),
                                label: optionGroup.label
                            }, existingOptions = [ existingParent ], optionGroupsCache.push(existingOptions), 
                            selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex], 
                            existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), 
                            lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index], 
                            (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, 
                            existingOption.label !== option.label && (updateLabelMap(labelMap, existingOption.label, !1), 
                            updateLabelMap(labelMap, option.label, !0), lastElement.text(existingOption.label = option.label), 
                            lastElement.prop("label", existingOption.label)), existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), 
                            lastElement[0].selected !== option.selected && (lastElement.prop("selected", existingOption.selected = option.selected), 
                            msie && lastElement.prop("selected", existingOption.selected))) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label), 
                            existingOptions.push(existingOption = {
                                element: element,
                                label: option.label,
                                id: option.id,
                                selected: option.selected
                            }), updateLabelMap(labelMap, option.label, !0), lastElement ? lastElement.after(element) : existingParent.element.append(element), 
                            lastElement = element);
                            for (index++; existingOptions.length > index; ) option = existingOptions.pop(), 
                            updateLabelMap(labelMap, option.label, !1), option.element.remove();
                            forEach(labelMap, function(count, label) {
                                count > 0 ? selectCtrl.addOption(label) : 0 > count && selectCtrl.removeOption(label);
                            });
                        }
                        for (;optionGroupsCache.length > groupIndex; ) optionGroupsCache.pop()[0].element.remove();
                    }
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], selectAs = / as /.test(match[0]) && match[1], selectAsFn = selectAs ? $parse(selectAs) : null, keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, trackKeysCache = {}, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ], locals = {};
                    nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), 
                    nullOption.remove()), selectElement.empty(), selectElement.on("change", selectionChanged), 
                    ctrl.$render = render, scope.$watchCollection(valuesFn, scheduleRendering), scope.$watchCollection(getLabels, scheduleRendering), 
                    multiple && scope.$watchCollection(function() {
                        return ctrl.$modelValue;
                    }, scheduleRendering);
                }
                if (ctrls[1]) {
                    for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, renderScheduled = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                    selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                }
            }
        };
    } ], optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text());
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.databound || (selectCtrl = nullSelectCtrl), interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                        attr.$set("value", newVal), oldVal !== newVal && selectCtrl.removeOption(oldVal), 
                        selectCtrl.addOption(newVal, element);
                    }) : selectCtrl.addOption(attr.value, element), element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ], styleDirective = valueFn({
        restrict: "E",
        terminal: !1
    });
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), 
    publishExternalAPI(angular), void jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    }));
}(window, document), !window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>'), 
angular.module("mm.foundation", [ "mm.foundation.tpls", "mm.foundation.accordion", "mm.foundation.alert", "mm.foundation.bindHtml", "mm.foundation.buttons", "mm.foundation.position", "mm.foundation.mediaQueries", "mm.foundation.dropdownToggle", "mm.foundation.interchange", "mm.foundation.transition", "mm.foundation.modal", "mm.foundation.offcanvas", "mm.foundation.pagination", "mm.foundation.tooltip", "mm.foundation.popover", "mm.foundation.progressbar", "mm.foundation.rating", "mm.foundation.tabs", "mm.foundation.topbar", "mm.foundation.tour", "mm.foundation.typeahead" ]), 
angular.module("mm.foundation.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/topbar/has-dropdown.html", "template/topbar/toggle-top-bar.html", "template/topbar/top-bar-dropdown.html", "template/topbar/top-bar-section.html", "template/topbar/top-bar.html", "template/tour/tour.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]), 
angular.module("mm.foundation.accordion", []).constant("accordionConfig", {
    closeOthers: !0
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function() {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(this.groups.indexOf(group), 1);
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: !0,
        replace: !1,
        templateUrl: "template/accordion/accordion.html"
    };
}).directive("accordionGroup", [ "$parse", function($parse) {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            var getIsOpen, setIsOpen;
            accordionCtrl.addGroup(scope), scope.isOpen = !1, attrs.isOpen && (getIsOpen = $parse(attrs.isOpen), 
            setIsOpen = getIsOpen.assign, scope.$parent.$watch(getIsOpen, function(value) {
                scope.isOpen = !!value;
            })), scope.$watch("isOpen", function(value) {
                value && accordionCtrl.closeOthers(scope), setIsOpen && setIsOpen(scope.$parent, value);
            });
        }
    };
} ]).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        compile: function(element, attr, transclude) {
            return function(scope, element, attr, accordionGroupCtrl) {
                accordionGroupCtrl.setHeading(transclude(scope, function() {}));
            };
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                heading && (element.html(""), element.append(heading));
            });
        }
    };
}), angular.module("mm.foundation.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close" in $attrs;
} ]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: !0,
        replace: !0,
        scope: {
            type: "=",
            close: "&"
        }
    };
}), angular.module("mm.foundation.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe), scope.$watch(attr.bindHtmlUnsafe, function(value) {
            element.html(value || "");
        });
    };
}), angular.module("mm.foundation.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass, this.toggleEvent = buttonConfig.toggleEvent;
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                element.hasClass(buttonsCtrl.activeClass) || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio)), ngModelCtrl.$render();
                });
            });
        }
    };
}).directive("btnCheckbox", function() {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("mm.foundation.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop];
    }
    function isStaticPositioned(element) {
        return "static" === (getStyle(element, "position") || "static");
    }
    var parentOffsetEl = function(element) {
        for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
        return offsetParent || docDomEl;
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element), offsetParentBCR = {
                top: 0,
                left: 0
            }, offsetParentEl = parentOffsetEl(element[0]);
            offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), 
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
            };
        }
    };
} ]), angular.module("mm.foundation.mediaQueries", []).factory("matchMedia", [ "$document", "$window", function($document, $window) {
    return $window.matchMedia || function(doc) {
        var bool, docElem = doc.documentElement, refNode = docElem.firstElementChild || docElem.firstChild, fakeBody = doc.createElement("body"), div = doc.createElement("div");
        return div.id = "mq-test-1", div.style.cssText = "position:absolute;top:-100em", 
        fakeBody.style.background = "none", fakeBody.appendChild(div), function(q) {
            return div.innerHTML = '&shy;<style media="' + q + '"> #mq-test-1 { width: 42px; }</style>', 
            docElem.insertBefore(fakeBody, refNode), bool = 42 === div.offsetWidth, docElem.removeChild(fakeBody), 
            {
                matches: bool,
                media: q
            };
        };
    }($document[0]);
} ]).factory("mediaQueries", [ "$document", "matchMedia", function($document, matchMedia) {
    var head = angular.element($document[0].querySelector("head"));
    head.append('<meta class="foundation-mq-topbar" />'), head.append('<meta class="foundation-mq-small" />'), 
    head.append('<meta class="foundation-mq-medium" />'), head.append('<meta class="foundation-mq-large" />');
    var regex = /^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, queries = {
        topbar: getComputedStyle(head[0].querySelector("meta.foundation-mq-topbar")).fontFamily.replace(regex, ""),
        small: getComputedStyle(head[0].querySelector("meta.foundation-mq-small")).fontFamily.replace(regex, ""),
        medium: getComputedStyle(head[0].querySelector("meta.foundation-mq-medium")).fontFamily.replace(regex, ""),
        large: getComputedStyle(head[0].querySelector("meta.foundation-mq-large")).fontFamily.replace(regex, "")
    };
    return {
        topbarBreakpoint: function() {
            return !matchMedia(queries.topbar).matches;
        },
        small: function() {
            return matchMedia(queries.small).matches;
        },
        medium: function() {
            return matchMedia(queries.medium).matches;
        },
        large: function() {
            return matchMedia(queries.large).matches;
        }
    };
} ]), angular.module("mm.foundation.dropdownToggle", [ "mm.foundation.position", "mm.foundation.mediaQueries" ]).controller("DropdownToggleController", [ "$scope", "$attrs", "mediaQueries", function($scope, $attrs, mediaQueries) {
    this.small = function() {
        return mediaQueries.small() && !mediaQueries.medium();
    };
} ]).directive("dropdownToggle", [ "$document", "$window", "$location", "$position", function($document, $window, $location, $position) {
    var openElement = null, closeMenu = angular.noop;
    return {
        restrict: "CA",
        scope: {
            dropdownToggle: "@"
        },
        controller: "DropdownToggleController",
        link: function(scope, element, attrs, controller) {
            var parent = element.parent(), dropdown = angular.element($document[0].querySelector(scope.dropdownToggle)), parentHasDropdown = function() {
                return parent.hasClass("has-dropdown");
            }, onClick = function(event) {
                dropdown = angular.element($document[0].querySelector(scope.dropdownToggle));
                var elementWasOpen = element === openElement;
                if (event.preventDefault(), event.stopPropagation(), openElement && closeMenu(), 
                !elementWasOpen && !element.hasClass("disabled") && !element.prop("disabled")) {
                    dropdown.css("display", "block");
                    var offset = $position.offset(element), parentOffset = $position.offset(angular.element(dropdown[0].offsetParent)), dropdownWidth = dropdown.prop("offsetWidth"), css = {
                        top: offset.top - parentOffset.top + offset.height + "px"
                    };
                    if (controller.small()) css.left = Math.max((parentOffset.width - dropdownWidth) / 2, 8) + "px", 
                    css.position = "absolute", css.width = "95%", css["max-width"] = "none"; else {
                        var left = Math.round(offset.left - parentOffset.left), rightThreshold = $window.innerWidth - dropdownWidth - 8;
                        left > rightThreshold && (left = rightThreshold, dropdown.removeClass("left").addClass("right")), 
                        css.left = left + "px", css.position = null, css["max-width"] = null;
                    }
                    dropdown.css(css), parentHasDropdown() && parent.addClass("hover"), openElement = element, 
                    closeMenu = function() {
                        $document.off("click", closeMenu), dropdown.css("display", "none"), closeMenu = angular.noop, 
                        openElement = null, parent.hasClass("hover") && parent.removeClass("hover");
                    }, $document.on("click", closeMenu);
                }
            };
            dropdown && dropdown.css("display", "none"), scope.$watch("$location.path", function() {
                closeMenu();
            }), element.on("click", onClick), element.on("$destroy", function() {
                element.off("click", onClick);
            });
        }
    };
} ]), angular.module("mm.foundation.interchange", [ "mm.foundation.mediaQueries" ]).factory("interchangeQueries", [ "$document", function($document) {
    for (var element, mediaSize, formatList = {
        "default": "only screen",
        landscape: "only screen and (orientation: landscape)",
        portrait: "only screen and (orientation: portrait)",
        retina: "only screen and (-webkit-min-device-pixel-ratio: 2),only screen and (min--moz-device-pixel-ratio: 2),only screen and (-o-min-device-pixel-ratio: 2/1),only screen and (min-device-pixel-ratio: 2),only screen and (min-resolution: 192dpi),only screen and (min-resolution: 2dppx)"
    }, classPrefix = "foundation-mq-", classList = [ "small", "medium", "large", "xlarge", "xxlarge" ], head = angular.element($document[0].querySelector("head")), i = 0; i < classList.length; i++) head.append('<meta class="' + classPrefix + classList[i] + '" />'), 
    element = getComputedStyle(head[0].querySelector("meta." + classPrefix + classList[i])), 
    mediaSize = element.fontFamily.replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ""), formatList[classList[i]] = mediaSize;
    return formatList;
} ]).factory("interchangeQueriesManager", [ "interchangeQueries", function(interchangeQueries) {
    return {
        add: function(name, media) {
            return name && media && angular.isString(name) && angular.isString(media) && !interchangeQueries[name] ? (interchangeQueries[name] = media, 
            !0) : !1;
        }
    };
} ]).factory("interchangeTools", [ "$window", "matchMedia", "interchangeQueries", function($window, matchMedia, namedQueries) {
    var parseAttribute = function(value) {
        for (var breaked, raw = value.split(/\[(.*?)\]/), i = raw.length, breaker = /^(.+)\,\ \((.+)\)$/, output = {}; i--; ) raw[i].replace(/[\W\d]+/, "").length > 4 && (breaked = breaker.exec(raw[i]), 
        breaked && 3 === breaked.length && (output[breaked[2]] = breaked[1]));
        return output;
    }, findCurrentMediaFile = function(files) {
        var file, media, match;
        for (file in files) if (media = namedQueries[file] || file, match = matchMedia(media), 
        match.matches) return files[file];
    };
    return {
        parseAttribute: parseAttribute,
        findCurrentMediaFile: findCurrentMediaFile
    };
} ]).directive("interchange", [ "$window", "$rootScope", "interchangeTools", function($window, $rootScope, interchangeTools) {
    var pictureFilePattern = /[A-Za-z0-9-_]+\.(jpg|jpeg|png|gif|bmp|tiff)\ *,/i;
    return {
        restrict: "A",
        scope: !0,
        priority: 450,
        compile: function($element, attrs) {
            return "DIV" !== $element[0].nodeName || pictureFilePattern.test(attrs.interchange) || $element.html('<ng-include src="currentFile"></ng-include>'), 
            {
                pre: function() {},
                post: function($scope, $element, attrs) {
                    var currentFile, nodeName;
                    switch (nodeName = $element && $element[0] && $element[0].nodeName, $scope.fileMap = interchangeTools.parseAttribute(attrs.interchange), 
                    nodeName) {
                      case "DIV":
                        currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap), $scope.type = /[A-Za-z0-9-_]+\.(jpg|jpeg|png|gif|bmp|tiff)$/i.test(currentFile) ? "background" : "include";
                        break;

                      case "IMG":
                        $scope.type = "image";
                        break;

                      default:
                        return;
                    }
                    var replace = function(e) {
                        var currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap);
                        if (!$scope.currentFile || $scope.currentFile !== currentFile) {
                            switch ($scope.currentFile = currentFile, $scope.type) {
                              case "image":
                                $element.attr("src", $scope.currentFile);
                                break;

                              case "background":
                                $element.css("background-image", "url(" + $scope.currentFile + ")");
                            }
                            $rootScope.$emit("replace", $element, $scope), e && $scope.$apply();
                        }
                    };
                    replace(), $window.addEventListener("resize", replace), $scope.$on("$destroy", function() {
                        $window.removeEventListener("resize", replace);
                    });
                }
            };
        }
    };
} ]), angular.module("mm.foundation.transition", []).factory("$transition", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) if (void 0 !== transElement.style[name]) return endEventNames[name];
    }
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer(), endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"], transitionEndHandler = function() {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler), deferred.resolve(element);
            });
        };
        return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function() {
            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), 
            endEventName || deferred.resolve(element);
        }), deferred.promise.cancel = function() {
            endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled");
        }, deferred.promise;
    }, transElement = document.createElement("trans"), transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }, animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames), 
    $transition.animationEndEventName = findEndEventName(animationEndEventNames), $transition;
} ]), angular.module("mm.foundation.modal", [ "mm.foundation.transition" ]).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key == stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key == stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope) {
            scope.animate = !1, $timeout(function() {
                scope.animate = !0;
            }), scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            };
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@",
            animate: "="
        },
        replace: !0,
        transclude: !0,
        templateUrl: "template/modal/window.html",
        link: function(scope, element, attrs) {
            scope.windowClass = attrs.windowClass || "", $timeout(function() {
                scope.animate = !0, element[0].querySelectorAll("[autofocus]").length > 0 ? element[0].querySelectorAll("[autofocus]")[0].focus() : element[0].querySelector("div").focus();
            });
        }
    };
} ]).factory("$modalStack", [ "$window", "$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($window, $transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex;
    }
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
            modalWindow.modalScope.$destroy(), body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0), 
            checkRemoveBackdrop();
        });
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 == backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
                backdropScopeRef.$destroy(), backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done());
        }
        scope.animate = !1;
        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
            var timeout = $timeout(afterAnimating, emulateTime);
            domEl.bind(transitionEndEventName, function() {
                $timeout.cancel(timeout), afterAnimating(), scope.$apply();
            });
        } else $timeout(afterAnimating, 0);
    }
    var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), $modalStack = {};
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.bind("keydown", function(evt) {
        var modal;
        27 === evt.which && (modal = openedWindows.top(), modal && modal.value.keyboard && $rootScope.$apply(function() {
            $modalStack.dismiss(modal.key);
        }));
    }), $modalStack.open = function(modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        });
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.index = currBackdropIndex, backdropDomEl = $compile("<div modal-backdrop></div>")(backdropScope), 
        body.append(backdropDomEl));
        var faux = angular.element('<div class="reveal-modal" style="z-index:-1""></div>');
        body.append(faux[0]);
        var marginTop = parseInt(getComputedStyle(faux[0]).top) || 0;
        faux.remove();
        var scrollY = $window.pageYOffset || 0, openAt = scrollY + marginTop, angularDomEl = angular.element('<div modal-window style="visibility: visible; top:' + openAt + 'px;"></div>');
        angularDomEl.attr("window-class", modal.windowClass), angularDomEl.attr("index", openedWindows.length() - 1), 
        angularDomEl.attr("animate", "animate"), angularDomEl.html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass(OPENED_MODAL_CLASS);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.resolve(result), removeModalWindow(modalInstance));
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.reject(reason), removeModalWindow(modalInstance));
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal; ) this.dismiss(topModal.key, reason), 
        topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(options.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data;
                });
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                return angular.forEach(resolves, function(value) {
                    (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)));
                }), promisesArr;
            }
            var $modal = {};
            return $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                var templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                return templateAndResolvePromise.then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, 
                    angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++];
                    }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals)), $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        windowClass: modalOptions.windowClass
                    });
                }, function(reason) {
                    modalResultDeferred.reject(reason);
                }), templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(!0);
                }, function() {
                    modalOpenedDeferred.reject(!1);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("mm.foundation.offcanvas", []).directive("offCanvasWrap", [ "$window", function($window) {
    return {
        scope: {},
        restrict: "C",
        link: function($scope, element) {
            var win = angular.element($window), sidebar = $scope.sidebar = element;
            $scope.hide = function() {
                sidebar.removeClass("move-left"), sidebar.removeClass("move-right");
            }, win.bind("resize.body", $scope.hide), $scope.$on("$destroy", function() {
                win.unbind("resize.body", $scope.hide);
            });
        },
        controller: [ "$scope", function($scope) {
            this.leftToggle = function() {
                $scope.sidebar.toggleClass("move-right");
            }, this.rightToggle = function() {
                $scope.sidebar.toggleClass("move-left");
            }, this.hide = function() {
                $scope.hide();
            };
        } ]
    };
} ]).directive("leftOffCanvasToggle", [ function() {
    return {
        require: "^offCanvasWrap",
        restrict: "C",
        link: function($scope, element, attrs, offCanvasWrap) {
            element.on("click", function() {
                offCanvasWrap.leftToggle();
            });
        }
    };
} ]).directive("rightOffCanvasToggle", [ function() {
    return {
        require: "^offCanvasWrap",
        restrict: "C",
        link: function($scope, element, attrs, offCanvasWrap) {
            element.on("click", function() {
                offCanvasWrap.rightToggle();
            });
        }
    };
} ]).directive("exitOffCanvas", [ function() {
    return {
        require: "^offCanvasWrap",
        restrict: "C",
        link: function($scope, element, attrs, offCanvasWrap) {
            element.on("click", function() {
                offCanvasWrap.hide();
            });
        }
    };
} ]).directive("offCanvasList", [ function() {
    return {
        require: "^offCanvasWrap",
        restrict: "C",
        link: function($scope, element, attrs, offCanvasWrap) {
            element.on("click", function() {
                offCanvasWrap.hide();
            });
        }
    };
} ]), angular.module("mm.foundation.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", "$interpolate", function($scope, $attrs, $parse, $interpolate) {
    var self = this, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(defaultItemsPerPage) {
        $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = defaultItemsPerPage;
    }, this.noPrevious = function() {
        return 1 === this.page;
    }, this.noNext = function() {
        return this.page === $scope.totalPages;
    }, this.isActive = function(page) {
        return this.page === page;
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.getAttributeValue = function(attribute, defaultValue, interpolate) {
        return angular.isDefined(attribute) ? interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute) : defaultValue;
    }, this.render = function() {
        this.page = parseInt($scope.page, 10) || 1, this.page > 0 && this.page <= $scope.totalPages && ($scope.pages = this.getPages(this.page, $scope.totalPages));
    }, $scope.selectPage = function(page) {
        !self.isActive(page) && page > 0 && page <= $scope.totalPages && ($scope.page = page, 
        $scope.onSelectPage({
            page: page
        }));
    }, $scope.$watch("page", function() {
        self.render();
    }), $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages();
    }), $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value), self.page > value ? $scope.selectPage(value) : self.render();
    });
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: !0,
        link: function(scope, element, attrs, paginationCtrl) {
            function makePage(number, text, isActive, isDisabled) {
                return {
                    number: number,
                    text: text,
                    active: isActive,
                    disabled: isDisabled
                };
            }
            var maxSize, boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks), directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks), firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, !0), previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, !0), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, !0), lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, !0), rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);
            paginationCtrl.init(config.itemsPerPage), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                maxSize = parseInt(value, 10), paginationCtrl.render();
            }), paginationCtrl.getPages = function(currentPage, totalPages) {
                var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
                endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; endPage >= number; number++) {
                    var page = makePage(number, number, paginationCtrl.isActive(number), !1);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1, !1);
                        pages.unshift(previousPageSet);
                    }
                    if (totalPages > endPage) {
                        var nextPageSet = makePage(endPage + 1, "...", !1, !1);
                        pages.push(nextPageSet);
                    }
                }
                if (directionLinks) {
                    var previousPage = makePage(currentPage - 1, previousText, !1, paginationCtrl.noPrevious());
                    pages.unshift(previousPage);
                    var nextPage = makePage(currentPage + 1, nextText, !1, paginationCtrl.noNext());
                    pages.push(nextPage);
                }
                if (boundaryLinks) {
                    var firstPage = makePage(1, firstText, !1, paginationCtrl.noPrevious());
                    pages.unshift(firstPage);
                    var lastPage = makePage(totalPages, lastText, !1, paginationCtrl.noNext());
                    pages.push(lastPage);
                }
                return pages;
            };
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: "« Previous",
    nextText: "Next »",
    align: !0
}).directive("pager", [ "pagerConfig", function(config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: !0,
        link: function(scope, element, attrs, paginationCtrl) {
            function makePage(number, text, isDisabled, isPrevious, isNext) {
                return {
                    number: number,
                    text: text,
                    disabled: isDisabled,
                    previous: align && isPrevious,
                    next: align && isNext
                };
            }
            var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, !0), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, !0), align = paginationCtrl.getAttributeValue(attrs.align, config.align);
            paginationCtrl.init(config.itemsPerPage), paginationCtrl.getPages = function(currentPage) {
                return [ makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), !0, !1), makePage(currentPage + 1, nextText, paginationCtrl.noNext(), !1, !0) ];
            };
        }
    };
} ]), angular.module("mm.foundation.tooltip", [ "mm.foundation.position", "mm.foundation.bindHtml" ]).provider("$tooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function(type, prefix, defaultTriggerShow) {
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow, hide = triggerMap[show] || show;
                return {
                    show: show,
                    hide: hide
                };
            }
            var options = angular.extend({}, defaultOptions, globalOptions), directiveName = snake_case(type), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "tt_title" + endSym + '" content="' + startSym + "tt_content" + endSym + '" placement="' + startSym + "tt_placement" + endSym + '" animation="tt_animation" is-open="tt_isOpen"></div>';
            return {
                restrict: "EA",
                scope: !0,
                compile: function() {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            scope.tt_isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (scope.tt_popupDelay ? (popupTimeout = $timeout(show, scope.tt_popupDelay, !1), 
                            popupTimeout.then(function(reposition) {
                                reposition();
                            })) : show()());
                        }
                        function hideTooltipBind() {
                            scope.$apply(function() {
                                hide();
                            });
                        }
                        function show() {
                            return scope.tt_content ? (createTooltip(), transitionTimeout && $timeout.cancel(transitionTimeout), 
                            tooltip.css({
                                top: 0,
                                left: 0,
                                display: "block"
                            }), appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip), 
                            positionTooltip(), scope.tt_isOpen = !0, scope.$digest(), positionTooltip) : angular.noop;
                        }
                        function hide() {
                            scope.tt_isOpen = !1, $timeout.cancel(popupTimeout), scope.tt_animation ? transitionTimeout = $timeout(removeTooltip, 500) : removeTooltip();
                        }
                        function createTooltip() {
                            tooltip && removeTooltip(), tooltip = tooltipLinker(scope, function() {}), scope.$digest();
                        }
                        function removeTooltip() {
                            tooltip && (tooltip.remove(), tooltip = null);
                        }
                        var tooltip, transitionTimeout, popupTimeout, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasRegisteredTriggers = !1, hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), positionTooltip = function() {
                            var position, ttWidth, ttHeight, ttPosition;
                            switch (position = appendToBody ? $position.offset(element) : $position.position(element), 
                            ttWidth = tooltip.prop("offsetWidth"), ttHeight = tooltip.prop("offsetHeight"), 
                            scope.tt_placement) {
                              case "right":
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left + position.width + 10
                                };
                                break;

                              case "bottom":
                                ttPosition = {
                                    top: position.top + position.height + 10,
                                    left: position.left
                                };
                                break;

                              case "left":
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left - ttWidth - 10
                                };
                                break;

                              default:
                                ttPosition = {
                                    top: position.top - ttHeight - 10,
                                    left: position.left
                                };
                            }
                            ttPosition.top += "px", ttPosition.left += "px", tooltip.css(ttPosition);
                        };
                        scope.tt_isOpen = !1, attrs.$observe(type, function(val) {
                            scope.tt_content = val, !val && scope.tt_isOpen && hide();
                        }), attrs.$observe(prefix + "Title", function(val) {
                            scope.tt_title = val;
                        }), attrs[prefix + "Placement"] = attrs[prefix + "Placement"] || null, attrs.$observe(prefix + "Placement", function(val) {
                            scope.tt_placement = angular.isDefined(val) && val ? val : options.placement;
                        }), attrs[prefix + "PopupDelay"] = attrs[prefix + "PopupDelay"] || null, attrs.$observe(prefix + "PopupDelay", function(val) {
                            var delay = parseInt(val, 10);
                            scope.tt_popupDelay = isNaN(delay) ? options.popupDelay : delay;
                        });
                        var unregisterTriggers = function() {
                            hasRegisteredTriggers && (angular.isFunction(triggers.show) ? unregisterTriggerFunction() : (element.unbind(triggers.show, showTooltipBind), 
                            element.unbind(triggers.hide, hideTooltipBind)));
                        }, unregisterTriggerFunction = function() {};
                        attrs[prefix + "Trigger"] = attrs[prefix + "Trigger"] || null, attrs.$observe(prefix + "Trigger", function(val) {
                            unregisterTriggers(), unregisterTriggerFunction(), triggers = getTriggers(val), 
                            angular.isFunction(triggers.show) ? unregisterTriggerFunction = scope.$watch(function() {
                                return triggers.show(scope, element, attrs);
                            }, function(val) {
                                return $timeout(val ? show : hide);
                            }) : triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), 
                            element.bind(triggers.hide, hideTooltipBind)), hasRegisteredTriggers = !0;
                        });
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation, 
                        attrs.$observe(prefix + "AppendToBody", function(val) {
                            appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                        }), appendToBody && scope.$on("$locationChangeSuccess", function() {
                            scope.tt_isOpen && hide();
                        }), scope.$on("$destroy", function() {
                            $timeout.cancel(transitionTimeout), $timeout.cancel(popupTimeout), unregisterTriggers(), 
                            unregisterTriggerFunction(), removeTooltip();
                        });
                    };
                }
            };
        };
    } ];
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).directive("tooltipHtmlUnsafe", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]), angular.module("mm.foundation.popover", [ "mm.foundation.tooltip" ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]), angular.module("mm.foundation.progressbar", [ "mm.foundation.transition" ]).constant("progressConfig", {
    animate: !0,
    max: 100
}).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", "$transition", function($scope, $attrs, progressConfig, $transition) {
    var self = this, bars = [], max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.addBar = function(bar, element) {
        var oldValue = 0, index = bar.$parent.$index;
        angular.isDefined(index) && bars[index] && (oldValue = bars[index].value), bars.push(bar), 
        this.update(element, bar.value, oldValue), bar.$watch("value", function(value, oldValue) {
            value !== oldValue && self.update(element, value, oldValue);
        }), bar.$on("$destroy", function() {
            self.removeBar(bar);
        });
    }, this.update = function(element, newValue, oldValue) {
        var percent = this.getPercentage(newValue);
        animate ? (element.css("width", this.getPercentage(oldValue) + "%"), $transition(element, {
            width: percent + "%"
        })) : element.css({
            transition: "none",
            width: percent + "%"
        });
    }, this.removeBar = function(bar) {
        bars.splice(bars.indexOf(bar), 1);
    }, this.getPercentage = function(value) {
        return Math.round(100 * value / max);
    };
} ]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        template: '<div class="progress" ng-transclude></div>'
    };
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
}), angular.module("mm.foundation.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", [ "$scope", "$attrs", "$parse", "ratingConfig", function($scope, $attrs, $parse, ratingConfig) {
    this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max, 
    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff, 
    this.createRateObjects = function(states) {
        for (var defaultOptions = {
            stateOn: this.stateOn,
            stateOff: this.stateOff
        }, i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, defaultOptions, states[i]);
        return states;
    }, $scope.range = this.createRateObjects(angular.isDefined($attrs.ratingStates) ? angular.copy($scope.$parent.$eval($attrs.ratingStates)) : new Array(this.maxRange)), 
    $scope.rate = function(value) {
        $scope.value === value || $scope.readonly || ($scope.value = value);
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.val = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.val = angular.copy($scope.value), $scope.onLeave();
    }, $scope.$watch("value", function(value) {
        $scope.val = value;
    }), $scope.readonly = !1, $attrs.readonly && $scope.$parent.$watch($parse($attrs.readonly), function(value) {
        $scope.readonly = !!value;
    });
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        scope: {
            value: "=",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0
    };
}), angular.module("mm.foundation.tabs", []).controller("TabsetController", [ "$scope", function($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(tab) {
        angular.forEach(tabs, function(tab) {
            tab.active = !1;
        }), tab.active = !0;
    }, ctrl.addTab = function(tab) {
        tabs.push(tab), (1 === tabs.length || tab.active) && ctrl.select(tab);
    }, ctrl.removeTab = function(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {},
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1, 
            scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : "tabs";
        }
    };
}).directive("tab", [ "$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function(scope, elm, attrs, tabsetCtrl) {
                var getActive, setActive;
                attrs.active ? (getActive = $parse(attrs.active), setActive = getActive.assign, 
                scope.$parent.$watch(getActive, function(value, oldVal) {
                    value !== oldVal && (scope.active = !!value);
                }), scope.active = getActive(scope.$parent)) : setActive = getActive = angular.noop, 
                scope.$watch("active", function(active) {
                    angular.isFunction(setActive) && (setActive(scope.$parent, active), active ? (tabsetCtrl.select(scope), 
                    scope.onSelect()) : scope.onDeselect());
                }), scope.disabled = !1, attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value;
                }), scope.select = function() {
                    scope.disabled || (scope.active = !0);
                }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope);
                }), scope.$transcludeFn = transclude;
            };
        }
    };
} ]).directive("tabHeadingTransclude", [ function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
} ]).directive("tabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("mm.foundation.topbar", [ "mm.foundation.mediaQueries" ]).factory("closest", [ function() {
    return function(el, selector) {
        for (var matchesSelector = function(node, selector) {
            for (var nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1; nodes[++i] && nodes[i] != node; ) ;
            return !!nodes[i];
        }, element = el[0]; element; ) {
            if (matchesSelector(element, selector)) return angular.element(element);
            element = element.parentElement;
        }
        return !1;
    };
} ]).directive("topBar", [ "$timeout", "$compile", "$window", "$document", "mediaQueries", function($timeout, $compile, $window, $document, mediaQueries) {
    return {
        scope: {
            stickyClass: "@",
            backText: "@",
            stickyOn: "=",
            customBackText: "=",
            isHover: "=",
            mobileShowParentLink: "=",
            scrolltop: "="
        },
        restrict: "EA",
        replace: !0,
        templateUrl: "template/topbar/top-bar.html",
        transclude: !0,
        link: function($scope, element) {
            var topbar = $scope.topbar = element, topbarContainer = topbar.parent(), body = angular.element($document[0].querySelector("body")), isSticky = $scope.isSticky = function() {
                var sticky = topbarContainer.hasClass($scope.settings.stickyClass);
                return sticky && "all" === $scope.settings.stickyOn ? !0 : sticky && mediaQueries.small() && "small" === $scope.settings.stickyOn ? !0 : sticky && mediaQueries.medium() && "medium" === $scope.settings.stickyOn ? !0 : sticky && mediaQueries.large() && "large" === $scope.settings.stickyOn ? !0 : !1;
            }, updateStickyPositioning = function() {
                if ($scope.stickyTopbar && $scope.isSticky()) {
                    var $class = angular.element($document[0].querySelector("." + $scope.settings.stickyClass)), distance = stickyoffset;
                    $window.pageYOffset > distance && !$class.hasClass("fixed") ? ($class.addClass("fixed"), 
                    body.css("padding-top", $scope.originalHeight + "px")) : $window.pageYOffset <= distance && $class.hasClass("fixed") && ($class.removeClass("fixed"), 
                    body.css("padding-top", ""));
                }
            };
            if ($scope.toggle = function(on) {
                if (!mediaQueries.topbarBreakpoint()) return !1;
                var expand = void 0 === on ? !topbar.hasClass("expanded") : on;
                expand ? topbar.addClass("expanded") : topbar.removeClass("expanded"), $scope.settings.scrolltop ? !expand && topbar.hasClass("fixed") ? (topbar.parent().addClass("fixed"), 
                topbar.removeClass("fixed"), body.css("padding-top", $scope.originalHeight + "px")) : expand && topbar.parent().hasClass("fixed") && (topbar.parent().removeClass("fixed"), 
                topbar.addClass("fixed"), body.css("padding-top", ""), $window.scrollTo(0, 0)) : (isSticky() && topbar.parent().addClass("fixed"), 
                topbar.parent().hasClass("fixed") && (expand ? (topbar.addClass("fixed"), topbar.parent().addClass("expanded"), 
                body.css("padding-top", $scope.originalHeight + "px")) : (topbar.removeClass("fixed"), 
                topbar.parent().removeClass("expanded"), updateStickyPositioning())));
            }, topbarContainer.hasClass("fixed") || isSticky()) {
                $scope.stickyTopbar = !0, $scope.height = topbarContainer[0].offsetHeight;
                var stickyoffset = topbarContainer[0].getBoundingClientRect().top;
            } else $scope.height = topbar[0].offsetHeight;
            $scope.originalHeight = $scope.height, $scope.$watch("height", function(h) {
                h ? topbar.css("height", h + "px") : topbar.css("height", "");
            });
            var lastBreakpoint = mediaQueries.topbarBreakpoint();
            angular.element($window).bind("resize", function() {
                var currentBreakpoint = mediaQueries.topbarBreakpoint();
                if (lastBreakpoint !== currentBreakpoint) {
                    lastBreakpoint = mediaQueries.topbarBreakpoint(), topbar.removeClass("expanded"), 
                    topbar.parent().removeClass("expanded"), $scope.height = "";
                    var sections = angular.element(topbar[0].querySelectorAll("section"));
                    angular.forEach(sections, function(section) {
                        angular.element(section.querySelectorAll("li.moved")).removeClass("moved");
                    }), $scope.$apply();
                }
            }), angular.element($window).bind("scroll", function() {
                updateStickyPositioning(), $scope.$apply();
            }), $scope.$on("$destroy", function() {
                angular.element($window).unbind("scroll"), angular.element($window).unbind("resize");
            }), topbarContainer.hasClass("fixed") && body.css("padding-top", $scope.originalHeight + "px");
        },
        controller: [ "$window", "$scope", "closest", function($window, $scope, closest) {
            $scope.settings = {}, $scope.settings.stickyClass = $scope.stickyClass || "sticky", 
            $scope.settings.backText = $scope.backText || "Back", $scope.settings.stickyOn = $scope.stickyOn || "all", 
            $scope.settings.customBackText = void 0 === $scope.customBackText ? !0 : $scope.customBackText, 
            $scope.settings.isHover = void 0 === $scope.isHover ? !0 : $scope.isHover, $scope.settings.mobileShowParentLink = void 0 === $scope.mobileShowParentLink ? !0 : $scope.mobileShowParentLink, 
            $scope.settings.scrolltop = void 0 === $scope.scrolltop ? !0 : $scope.scrolltop, 
            this.settings = $scope.settings, $scope.index = 0;
            var outerHeight = function(el) {
                var height = el.offsetHeight, style = el.currentStyle || getComputedStyle(el);
                return height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
            }, sections = [];
            this.addSection = function(section) {
                sections.push(section);
            }, this.removeSection = function(section) {
                var index = sections.indexOf(section);
                index > -1 && sections.splice(index, 1);
            };
            var dir = /rtl/i.test($document.find("html").attr("dir")) ? "right" : "left";
            $scope.$watch("index", function(index) {
                for (var i = 0; i < sections.length; i++) sections[i].move(dir, index);
            }), this.toggle = function(on) {
                $scope.toggle(on);
                for (var i = 0; i < sections.length; i++) sections[i].reset();
                $scope.index = 0, $scope.height = "", $scope.$apply();
            }, this.back = function(event) {
                if (!($scope.index < 1) && mediaQueries.topbarBreakpoint()) {
                    var $link = angular.element(event.currentTarget), $movedLi = closest($link, "li.moved"), $previousLevelUl = $movedLi.parent();
                    $scope.index = $scope.index - 1, $scope.height = 0 === $scope.index ? "" : $scope.originalHeight + outerHeight($previousLevelUl[0]), 
                    $timeout(function() {
                        $movedLi.removeClass("moved");
                    }, 300);
                }
            }, this.forward = function(event) {
                if (!mediaQueries.topbarBreakpoint()) return !1;
                var $link = angular.element(event.currentTarget), $selectedLi = closest($link, "li");
                $selectedLi.addClass("moved"), $scope.height = $scope.originalHeight + outerHeight($link.parent()[0].querySelector("ul")), 
                $scope.index = $scope.index + 1, $scope.$apply();
            };
        } ]
    };
} ]).directive("toggleTopBar", [ "closest", function(closest) {
    return {
        scope: {},
        require: "^topBar",
        restrict: "A",
        replace: !0,
        templateUrl: "template/topbar/toggle-top-bar.html",
        transclude: !0,
        link: function($scope, element, attrs, topBar) {
            element.bind("click", function(event) {
                var li = closest(angular.element(event.currentTarget), "li");
                li.hasClass("back") || li.hasClass("has-dropdown") || topBar.toggle();
            }), $scope.$on("$destroy", function() {
                element.unbind("click");
            });
        }
    };
} ]).directive("topBarSection", [ "$compile", "closest", function($compile, closest) {
    return {
        scope: {},
        require: "^topBar",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/topbar/top-bar-section.html",
        transclude: !0,
        link: function($scope, element, attrs, topBar) {
            var section = element;
            $scope.reset = function() {
                angular.element(section[0].querySelectorAll("li.moved")).removeClass("moved");
            }, $scope.move = function(dir, index) {
                section.css("left" === dir ? {
                    left: -100 * index + "%"
                } : {
                    right: -100 * index + "%"
                });
            }, topBar.addSection($scope), $scope.$on("$destroy", function() {
                topBar.removeSection($scope);
            });
            var links = section[0].querySelectorAll("li>a");
            angular.forEach(links, function(link) {
                var $link = angular.element(link), li = closest($link, "li");
                li.hasClass("has-dropdown") || li.hasClass("back") || li.hasClass("title") || ($link.bind("click", function() {
                    topBar.toggle(!1);
                }), $scope.$on("$destroy", function() {
                    $link.bind("click");
                }));
            });
        }
    };
} ]).directive("hasDropdown", [ "mediaQueries", function(mediaQueries) {
    return {
        scope: {},
        require: "^topBar",
        restrict: "A",
        templateUrl: "template/topbar/has-dropdown.html",
        replace: !0,
        transclude: !0,
        link: function($scope, element, attrs, topBar) {
            $scope.triggerLink = element.children("a")[0];
            var $link = angular.element($scope.triggerLink);
            $link.bind("click", function(event) {
                topBar.forward(event);
            }), $scope.$on("$destroy", function() {
                $link.unbind("click");
            }), element.bind("mouseenter", function() {
                topBar.settings.isHover && !mediaQueries.topbarBreakpoint() && element.addClass("not-click");
            }), element.bind("click", function() {
                topBar.settings.isHover || mediaQueries.topbarBreakpoint() || element.toggleClass("not-click");
            }), element.bind("mouseleave", function() {
                element.removeClass("not-click");
            }), $scope.$on("$destroy", function() {
                element.unbind("click"), element.unbind("mouseenter"), element.unbind("mouseleave");
            });
        },
        controller: [ "$window", "$scope", function($window, $scope) {
            this.triggerLink = $scope.triggerLink;
        } ]
    };
} ]).directive("topBarDropdown", [ "$compile", function($compile) {
    return {
        scope: {},
        require: [ "^topBar", "^hasDropdown" ],
        restrict: "A",
        replace: !0,
        templateUrl: "template/topbar/top-bar-dropdown.html",
        transclude: !0,
        link: function($scope, element, attrs, ctrls) {
            var topBar = ctrls[0], hasDropdown = ctrls[1], $link = angular.element(hasDropdown.triggerLink), url = $link.attr("href");
            $scope.linkText = $link.text(), $scope.back = function(event) {
                topBar.back(event);
            }, $scope.backText = topBar.settings.customBackText ? topBar.settings.backText : "&laquo; " + $link.html();
            var $titleLi;
            $titleLi = angular.element(topBar.settings.mobileShowParentLink && url && url.length > 1 ? '<li class="title back js-generated"><h5><a href="#" ng-click="back($event);">{{backText}}</a></h5></li><li><a class="parent-link js-generated" href="' + url + '">{{linkText}}</a></li>' : '<li class="title back js-generated"><h5><a href="" ng-click="back($event);">{{backText}}</a></h5></li>'), 
            $compile($titleLi)($scope), element.prepend($titleLi);
        }
    };
} ]), angular.module("mm.foundation.tour", [ "mm.foundation.position", "mm.foundation.tooltip" ]).service("$tour", [ "$window", function($window) {
    function getCurrentStep() {
        return parseInt($window.localStorage.getItem("mm.tour.step"), 10);
    }
    function setCurrentStep(step) {
        currentIndex = step, $window.localStorage.setItem("mm.tour.step", step);
    }
    var currentIndex = getCurrentStep(), steps = {};
    this.add = function(index, attrs) {
        steps[index] = attrs;
    }, this.has = function(index) {
        return !!steps[index];
    }, this.isActive = function() {
        return currentIndex > 0;
    }, this.current = function(index) {
        return index ? void setCurrentStep(currentIndex) : currentIndex;
    }, this.start = function() {
        setCurrentStep(1);
    }, this.next = function() {
        setCurrentStep(currentIndex + 1);
    }, this.end = function() {
        setCurrentStep(0);
    };
} ]).directive("stepTextPopup", [ "$tour", function($tour) {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tour/tour.html",
        link: function(scope, element) {
            scope.isLastStep = function() {
                return !$tour.has($tour.current() + 1);
            }, scope.endTour = function() {
                element.remove(), $tour.end();
            }, scope.nextStep = function() {
                element.remove(), $tour.next();
            };
        }
    };
} ]).directive("stepText", [ "$position", "$tooltip", "$tour", "$window", function($position, $tooltip, $tour, $window) {
    function isElementInViewport(element) {
        var rect = element[0].getBoundingClientRect();
        return rect.top >= 0 && rect.left >= 0 && rect.bottom <= $window.innerHeight - 80 && rect.right <= $window.innerWidth;
    }
    function show(scope, element, attrs) {
        var index = parseInt(attrs.stepIndex, 10);
        if ($tour.isActive() && index && ($tour.add(index, attrs), index === $tour.current())) {
            if (!isElementInViewport(element)) {
                var offset = $position.offset(element);
                $window.scrollTo(0, offset.top - $window.innerHeight / 2);
            }
            return !0;
        }
        return !1;
    }
    return $tooltip("stepText", "step", show);
} ]), angular.module("mm.foundation.typeahead", [ "mm.foundation.position", "mm.foundation.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_' but got '" + input + "'.");
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            var hasFocus, minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : !1, $setModelValue = $parse(attrs.ngModel).assign, parserResult = typeaheadParser.parse(attrs.typeahead), popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            var scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            var resetMatches = function() {
                scope.matches = [], scope.activeIdx = -1;
            }, getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    if (inputValue === modelCtrl.$viewValue && hasFocus) {
                        if (matches.length > 0) {
                            scope.activeIdx = 0, scope.matches.length = 0;
                            for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                            scope.matches.push({
                                label: parserResult.viewMapper(scope, locals),
                                model: matches[i]
                            });
                            scope.query = inputValue, scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                            scope.position.top = scope.position.top + element.prop("offsetHeight");
                        } else resetMatches();
                        isLoadingSetter(originalScope, !1);
                    }
                }, function() {
                    resetMatches(), isLoadingSetter(originalScope, !1);
                });
            };
            resetMatches(), scope.query = void 0;
            var timeoutPromise;
            modelCtrl.$parsers.unshift(function(inputValue) {
                return inputValue && inputValue.length >= minSearch ? waitTime > 0 ? (timeoutPromise && $timeout.cancel(timeoutPromise), 
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
                resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
                inputValue);
            }), modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue, locals = {};
                return inputFormatter ? (locals.$model = modelValue, inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
                candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
                emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
            }), scope.select = function(activeIdx) {
                var model, item, locals = {};
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model, model = parserResult.modelMapper(originalScope, locals), 
                $setModelValue(originalScope, model), modelCtrl.$setValidity("editable", !0), onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }), resetMatches(), element[0].focus();
            }, element.bind("keydown", function(evt) {
                0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which) && (evt.preventDefault(), 
                40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
                scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                    scope.select(scope.activeIdx);
                }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest()));
            }), element.bind("blur", function() {
                hasFocus = !1;
            }), element.bind("focus", function() {
                hasFocus = !0;
            });
            var dismissClickHandler = function(evt) {
                element[0] !== evt.target && (resetMatches(), scope.$digest());
            };
            $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            var $popup = $compile(popUpEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup);
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return scope.matches.length > 0;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    return function(matchItem, query) {
        return query ? matchItem.replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
    };
}), angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<dd>\n  <a ng-click="isOpen = !isOpen" ng-class="{ active: isOpen }"  accordion-transclude="heading">{{heading}}</a>\n  <div class="content" ng-style="isOpen ? {display: \'block\'} : {}" ng-transclude></div>\n</dd>\n');
} ]), angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<dl class="accordion" ng-transclude></dl>\n');
} ]), angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", "<div class='alert-box' ng-class='(type || \"\")'>\n  <span ng-transclude></span>\n  <a ng-show='closeable' class='close' ng-click='close()'>&times;</a>\n</div>\n");
} ]), angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="reveal-modal-bg fade" ng-class="{in: animate}" ng-click="close($event)" style="display: block"></div>\n');
} ]), angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" class="reveal-modal fade {{ windowClass }}"\n  ng-class="{in: animate}" style="display: block; visibility: visible">\n  <div ng-transclude></div>\n</div>\n');
} ]), angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pagination">\n  <li ng-repeat="page in pages" class="arrow" ng-class="{unavailable: page.disabled, left: page.previous, right: page.next}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>\n');
} ]), angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-repeat="page in pages" ng-class="{arrow: $first || $last, current: page.active, unavailable: page.disabled}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>\n');
} ]), angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<span class="tooltip tip-{{placement}}"\n  ng-class="{ in: isOpen(), fade: animation() }"\n  style="width: auto">\n  <span bind-html-unsafe="content"></span>\n  <span class="nub"></span>\n</span>\n');
} ]), angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<span class="tooltip tip-{{placement}}"\n  ng-class="{ in: isOpen(), fade: animation() }"\n  style="width: auto">\n  <span ng-bind="content"></span>\n  <span class="nub"></span>\n</span>\n');
} ]), angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="joyride-tip-guide" ng-class="{ in: isOpen(), fade: animation() }">\n  <span class="joyride-nub" ng-class="{\n    bottom: placement === \'top\',\n    left: placement === \'right\',\n    right: placement === \'left\',\n    top: placement === \'bottom\'\n  }"></span>\n  <div class="joyride-content-wrapper">\n    <h4 ng-bind="title" ng-show="title"></h4>\n    <p ng-bind="content"></p>\n  </div>\n</div>\n');
} ]), angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<span class="meter" ng-transclude></span>\n');
} ]), angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-class="type" ng-transclude></div>\n');
} ]), angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress" ng-class="type">\n  <span class="meter" ng-transclude></span>\n</div>\n');
} ]), angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()">\n  <i ng-repeat="r in range" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="fa"\n    ng-class="$index < val && (r.stateOn || \'fa-star\') || (r.stateOff || \'fa-star-o\')"></i>\n</span>\n');
} ]), angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<dd ng-class="{active: active}">\n  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</dd>\n');
} ]), angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", '<div class="tabbable">\n  <dl class="tabs" ng-class="{\'vertical\': vertical}" ng-transclude></dl>\n  <div class="tabs-content" ng-class="{\'vertical\': vertical}">\n    <div class="content" \n      ng-repeat="tab in tabs" \n      ng-class="{active: tab.active}">\n      <div tab-content-transclude="tab"></div>\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("template/topbar/has-dropdown.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/topbar/has-dropdown.html", '<li class="has-dropdown" ng-transclude></li>');
} ]), angular.module("template/topbar/toggle-top-bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/topbar/toggle-top-bar.html", '<li class="toggle-topbar menu-icon" ng-transclude></li>');
} ]), angular.module("template/topbar/top-bar-dropdown.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/topbar/top-bar-dropdown.html", '<ul class="dropdown" ng-transclude></ul>');
} ]), angular.module("template/topbar/top-bar-section.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/topbar/top-bar-section.html", '<section class="top-bar-section" ng-transclude></section>');
} ]), angular.module("template/topbar/top-bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/topbar/top-bar.html", '<nav class="top-bar" ng-transclude></nav>');
} ]), angular.module("template/tour/tour.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tour/tour.html", '<div class="joyride-tip-guide" ng-class="{ in: isOpen(), fade: animation() }">\n  <span class="joyride-nub" ng-class="{\n    bottom: placement === \'top\',\n    left: placement === \'right\',\n    right: placement === \'left\',\n    top: placement === \'bottom\'\n  }"></span>\n  <div class="joyride-content-wrapper">\n    <h4 ng-bind="title" ng-show="title"></h4>\n    <p ng-bind="content"></p>\n    <a class="small button joyride-next-tip" ng-show="!isLastStep()" ng-click="nextStep()">Next</a>\n    <a class="small button joyride-next-tip" ng-show="isLastStep()" ng-click="endTour()">End</a>\n    <a class="joyride-close-tip" ng-click="endTour()">&times;</a>\n  </div>\n</div>\n');
} ]), angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>');
} ]), angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"f-dropdown\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" + '    <li ng-repeat="match in matches" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n');
} ]);